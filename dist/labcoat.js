// Generated by CoffeeScript 1.12.4

/*

    ............... LABCOAT ................

     A client-side frontend for Mastodon, a
    free & open-source social network server
               - - by Kibigo! - -

        Licensed under the MIT License.
           Source code available at:
      https://github.com/marrus-sh/labcoat

                Version 0.2.0
 */

(function() {
  var Columns, IndexRoute, Locales, Modules, ReactPureRenderMixin, Route, Router, Shared, UI,
    slice = [].slice,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Object.defineProperty(window, "彁", {
    value: React.createElement
  });

  if (typeof ReactPureRenderMixin === "undefined" || ReactPureRenderMixin === null) {
    ReactPureRenderMixin = React.addons.PureRenderMixin;
  }

  Columns = {};

  Columns.Column = function(props) {
    return 彁('div', (props.id != null ? {
      id: props.id,
      className: "labcoat-column"
    } : {
      className: "labcoat-column"
    }), props.children);
  };

  Columns.GoLink = function(props) {
    return 彁(ReactRouter.Link, {
      to: props.to,
      "aria-hidden": true
    }, 彁(Shared.Icon, {
      name: props.icon
    }), props.children);
  };

  Columns.GoLink.propTypes = {
    to: React.PropTypes.string.isRequired,
    icon: React.PropTypes.string.isRequired
  };

  Columns.Heading = function(props) {
    return 彁('h2', {
      className: "labcoat-heading"
    }, props.icon ? 彁(Shared.Icon, {
      name: props.icon
    }) : null, props.children);
  };

  Columns.Heading.propTypes = {
    icon: React.PropTypes.string
  };

  Columns.Status = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      type: React.PropTypes.object.isRequired,
      id: React.PropTypes.number.isRequired,
      href: React.PropTypes.string,
      author: React.PropTypes.object.isRequired,
      inReplyTo: React.PropTypes.number,
      content: React.PropTypes.string,
      datetime: React.PropTypes.object,
      isReblogged: React.PropTypes.bool,
      isFavourited: React.PropTypes.bool,
      isNSFW: React.PropTypes.bool,
      message: React.PropTypes.string,
      visibility: React.PropTypes.object,
      mediaAttachments: React.PropTypes.array,
      mentions: React.PropTypes.array,
      rebloggedBy: React.PropTypes.object,
      favouritedBy: React.PropTypes.object,
      follower: React.PropTypes.object
    },
    contextTypes: {
      router: React.PropTypes.object.isRequired
    },
    getListOfMentions: function() {
      switch (this.props.mentions.length) {
        case 0:
          return [];
        case 1:
          return [
            彁(ReactRouter.Link, {
              to: "/user/" + this.props.mentions[0].id
            }, 彁("code", {
              className: "labcoat-username"
            }, this.props.mentions[0].username))
          ];
        case 2:
          return [
            彁(ReactRouter.Link, {
              to: "/user/" + this.props.mentions[0].id
            }, 彁("code", {
              className: "labcoat-username"
            }, this.props.mentions[0].username)), 彁(ReactIntl.FormattedMessage, {
              id: "character.space",
              message: " "
            }), 彁(ReactIntl.FormattedMessage, {
              id: "status.and",
              message: "and"
            }), 彁(ReactIntl.FormattedMessage, {
              id: "character.space",
              message: " "
            }), 彁(ReactRouter.Link, {
              to: "/user/" + this.props.mentions[1].id
            }, 彁("code", {
              className: "labcoat-username"
            }, this.props.mentions[1].username))
          ];
        case 3:
          return [
            彁(ReactRouter.Link, {
              to: "/user/" + this.props.mentions[0].id
            }, 彁("code", {
              className: "labcoat-username"
            }, this.props.mentions[0].username)), 彁(ReactIntl.FormattedMessage, {
              id: "character.comma",
              message: ", "
            }), 彁(ReactRouter.Link, {
              to: "/user/" + this.props.mentions[1].id
            }, 彁("code", {
              className: "labcoat-username"
            }, this.props.mentions[1].username)), 彁(ReactIntl.FormattedMessage, {
              id: "character.comma",
              message: ", "
            }), 彁(ReactIntl.FormattedMessage, {
              id: "status.and",
              message: "and"
            }), 彁(ReactIntl.FormattedMessage, {
              id: "character.space",
              message: " "
            }), 彁(ReactRouter.Link, {
              to: "/user/" + this.props.mentions[2].id
            }, 彁("code", {
              className: "labcoat-username"
            }, this.props.mentions[2].username))
          ];
        default:
          return [
            彁(ReactRouter.Link, {
              to: "/user/" + this.props.mentions[0].id
            }, 彁("code", {
              className: "labcoat-username"
            }, this.props.mentions[0].username)), 彁(ReactIntl.FormattedMessage, {
              id: "character.space",
              message: " "
            }), 彁(ReactIntl.FormattedMessage, {
              id: "status.etal",
              message: "et al."
            })
          ];
      }
    },
    render: function() {
      if (this.props.follower) {
        return 彁("article", {
          className: "labcoat-status"
        }, 彁(Shared.IDCard, {
          account: this.props.follower
        }), 彁(ReactIntl.FormattedMessage, {
          id: "character.space",
          message: " "
        }), 彁(ReactIntl.FormattedMessage, {
          id: "status.followedyou",
          message: "followed you!"
        }));
      } else {
        return 彁("article", {
          className: "labcoat-status" + (this.props.isFavourited ? " labcoat-status--favourited" : "")
        }, (this.props.rebloggedBy != null) || (this.props.favouritedBy != null) || (this.props.inReplyTo != null) ? 彁.apply(null, ["aside", null].concat(slice.call(((function() {
          var ref1, ref2, ref3;
          switch (false) {
            case !((this.props.inReplyTo != null) && (this.props.rebloggedBy != null)):
              return [彁(ReactRouter.Link, {
                  to: "/user/" + this.props.rebloggedBy.id
                }, 彁("code", {
                  className: "labcoat-username"
                }, this.props.rebloggedBy.username)), 彁(ReactIntl.FormattedMessage, {
                  id: "character.space",
                  message: " "
                })].concat(slice.call((((ref1 = this.props.mentions) != null ? ref1.length : void 0) ? [彁(ReactIntl.FormattedMessage, {
                    id: "status.rebloggedthisreplyto",
                    message: "boosted this reply to"
                  }), 彁(ReactIntl.FormattedMessage, {
                    id: "character.space",
                    message: " "
                  })].concat(slice.call(this.getListOfMentions())) : [
                  彁(ReactIntl.FormattedMessage, {
                    id: "status.rebloggedthisreply",
                    message: "boosted this reply"
                  })
                ])));
            case !((this.props.inReplyTo != null) && (this.props.favouritedBy != null)):
              return [彁(ReactRouter.Link, {
                  to: "/user/" + this.props.favouritedBy.id
                }, 彁("code", {
                  className: "labcoat-username"
                }, this.props.favouritedBy.username)), 彁(ReactIntl.FormattedMessage, {
                  id: "character.space",
                  message: " "
                })].concat(slice.call((((ref2 = this.props.mentions) != null ? ref2.length : void 0) ? [彁(ReactIntl.FormattedMessage, {
                    id: "status.favouritedthisreplyto",
                    message: "highlighted this reply to"
                  }), 彁(ReactIntl.FormattedMessage, {
                    id: "character.space",
                    message: " "
                  })].concat(slice.call(this.getListOfMentions())) : [
                  彁(ReactIntl.FormattedMessage, {
                    id: "status.favouritedthisreply",
                    message: "highlighted this reply"
                  })
                ])));
            case this.props.rebloggedBy == null:
              return [
                彁(ReactRouter.Link, {
                  to: "/user/" + this.props.rebloggedBy.id
                }, 彁("code", {
                  className: "labcoat-username"
                }, this.props.rebloggedBy.username)), 彁(ReactIntl.FormattedMessage, {
                  id: "character.space",
                  message: " "
                }), 彁(ReactIntl.FormattedMessage, {
                  id: "status.rebloggedthisstatus",
                  message: "boosted this post"
                })
              ];
            case this.props.favouritedBy == null:
              return [
                彁(ReactRouter.Link, {
                  to: "/user/" + this.props.favouritedBy.id
                }, 彁("code", {
                  className: "labcoat-username"
                }, this.props.favouritedBy.username)), 彁(ReactIntl.FormattedMessage, {
                  id: "character.space",
                  message: " "
                }), 彁(ReactIntl.FormattedMessage, {
                  id: "status.favouritedthisstatus",
                  message: "highlighted this post"
                })
              ];
            case this.props.inReplyTo == null:
              if ((ref3 = this.props.mentions) != null ? ref3.length : void 0) {
                return [彁(ReactIntl.FormattedMessage, {
                    id: "status.inreplyto",
                    message: "In reply to"
                  }), 彁(ReactIntl.FormattedMessage, {
                    id: "character.space",
                    message: " "
                  })].concat(slice.call(this.getListOfMentions()));
              } else {
                return [
                  彁(ReactIntl.FormattedMessage, {
                    id: "status.inreplytoself",
                    message: "In reply to themselves"
                  })
                ];
              }
          }
        }).call(this))))) : null, 彁("header", null, 彁(Shared.IDCard, {
          account: this.props.author
        }), 彁(ReactIntl.FormattedRelative, {
          value: Date.parse(this.props.datetime)
        }, (function(_this) {
          return function(formattedDate) {
            return 彁("time", {
              dateTime: _this.props.datetime,
              title: _this.props.datetime
            }, formattedDate);
          };
        })(this))), 彁("div", {
          className: "labcoat-statusContent",
          dangerouslySetInnerHTML: {
            __html: this.props.content
          }
        }), this.props.type === Laboratory.Post.Type.STATUS || this.props.author.relationship !== Laboratory.Profile.Relationship.SELF ? 彁("footer", null, 彁(Shared.Action, {
          className: "labcoat-reply",
          icon: "icon.reply",
          label: 彁(ReactIntl.FormattedMessage, {
            id: "status.reply",
            defaultMessage: "Reply"
          }),
          action: (function(_this) {
            return function() {
              return _this.context.router.push("/compose?text=" + (_this.props.author.relationship !== Laboratory.Profile.Relationship.SELF ? "@" + _this.props.author.localAccount : "") + "&inReplyTo=" + _this.props.id);
            };
          })(this)
        }), this.props.isFavourited ? 彁(Shared.Action, {
          active: true,
          className: "labcoat-unfavourite",
          icon: "icon.unfavourite",
          label: 彁(ReactIntl.FormattedMessage, {
            id: "status.unfavourite",
            defaultMessage: "Unhighlight"
          }),
          action: (new Laboratory.Post.SetFavourite({
            id: this.props.id,
            value: false
          })).start
        }) : 彁(Shared.Action, {
          active: false,
          className: "labcoat-favourite",
          icon: "icon.favourite",
          label: 彁(ReactIntl.FormattedMessage, {
            id: "status.favourite",
            defaultMessage: "Highlight"
          }),
          action: (new Laboratory.Post.SetFavourite({
            id: this.props.id,
            value: true
          })).start
        }), this.props.isReblogged ? 彁(Shared.Action, {
          active: true,
          className: "labcoat-unreblog",
          icon: "icon.unreblog",
          label: 彁(ReactIntl.FormattedMessage, {
            id: "status.unreblog",
            defaultMessage: "Unboost"
          }),
          action: (new Laboratory.Post.SetBoost({
            id: this.props.id,
            value: false
          })).start
        }) : this.props.visibility & Laboratory.Post.Visibility.REBLOGGABLE ? 彁(Shared.Action, {
          active: false,
          className: "labcoat-reblog",
          icon: "icon.reblog",
          label: 彁(ReactIntl.FormattedMessage, {
            id: "status.reblog",
            defaultMessage: "Boost"
          }),
          action: (new Laboratory.Post.SetBoost({
            id: this.props.id,
            value: true
          })).start
        }) : 彁(Shared.Action, {
          active: false,
          className: "labcoat-noreblog",
          icon: "icon.noreblog",
          disabled: true,
          label: 彁(ReactIntl.FormattedMessage, {
            id: "status.noreblog",
            defaultMessage: "Private"
          })
        })) : null);
      }
    }
  });

  Columns.Empty = function() {
    return 彁(Columns.Column, {
      id: "labcoat-empty"
    }, 彁(Columns.Heading));
  };

  Columns.Go = function(props) {
    var key, value;
    return 彁(Columns.Column, {
      id: "labcoat-go"
    }, 彁(Columns.Heading, {
      icon: "icon.go"
    }, 彁(ReactIntl.FormattedMessage, {
      id: "go.heading",
      defaultMessage: "let's GO!"
    })), 彁("nav", {
      className: "labcoat-columnnav"
    }, 彁(Columns.GoLink, {
      to: "/user/" + props.myID,
      icon: "icon.profile"
    }, 彁(ReactIntl.FormattedMessage, {
      id: 'go.profile',
      defaultMessage: "Profile"
    })), 彁(Columns.GoLink, {
      to: "/community",
      icon: "icon.community"
    }, 彁(ReactIntl.FormattedMessage, {
      id: 'go.community',
      defaultMessage: "Community"
    })), 彁(Columns.GoLink, {
      to: "/global",
      icon: "icon.global"
    }, 彁(ReactIntl.FormattedMessage, {
      id: 'go.global',
      defaultMessage: "Global"
    }))), 彁("footer", {
      className: "labcoat-columnfooter"
    }, 彁.apply(null, ["nav", null].concat(slice.call((function() {
      var ref1, results;
      ref1 = (props.footerLinks != null ? props.footerLinks : {});
      results = [];
      for (key in ref1) {
        value = ref1[key];
        results.push(彁("a", {
          href: value,
          target: "_self"
        }, key));
      }
      return results;
    })())))));
  };

  Columns.Go.propTypes = {
    footerLinks: React.PropTypes.object,
    myID: React.PropTypes.number.isRequired
  };

  Columns.NotFound = function() {
    return 彁(Columns.Column, {
      id: "labcoat-notfound"
    }, 彁(Columns.Heading, {
      icon: "icon.notfound"
    }, 彁(ReactIntl.FormattedMessage, {
      id: 'notfound.notfound',
      defaultMessage: "Not found"
    })), 彁(ReactIntl.FormattedMessage, {
      id: 'notfound.notfound',
      defaultMessage: "Not found"
    }));
  };

  Columns.Timeline = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      name: React.PropTypes.string.isRequired
    },
    getInitialState: function() {
      return {
        timeline: null
      };
    },
    request: null,
    handleResponse: function(event) {
      return this.setState({
        timeline: event.detail.response
      });
    },
    getParams: function(name) {
      if (name == null) {
        name = this.props.name;
      }
      switch (false) {
        case name !== "home":
          return {
            type: Laboratory.Timeline.Type.HOME,
            query: "",
            isLocal: false
          };
        case name !== "community":
          return {
            type: Laboratory.Timeline.Type.PUBLIC,
            query: "",
            isLocal: true
          };
        case name !== "global":
          return {
            type: Laboratory.Timeline.Type.PUBLIC,
            query: "",
            isLocal: false
          };
        case (name.substr(0, 8)) !== "hashtag/":
          return {
            type: Laboratory.Timeline.Type.HASHTAG,
            query: name.substr(8),
            isLocal: false
          };
        case (name.substr(0, 5)) !== "user/":
          return {
            type: Laboratory.Timeline.Type.ACCOUNT,
            query: name.substr(5),
            isLocal: false
          };
        case name !== "notifications":
          return {
            type: Laboratory.Timeline.Type.NOTIFICATIONS,
            query: "",
            isLocal: false
          };
        case name !== "highlights":
          return {
            type: Laboratory.Timeline.Type.FAVOURITES,
            query: "",
            isLocal: false
          };
        default:
          return {
            type: Laboratory.Timeline.Type.UNDEFINED,
            query: "",
            isLocal: false
          };
      }
    },
    getIcon: function() {
      switch (name) {
        case "home":
          return "icon.home";
        case "community":
          return "icon.community";
        case "global":
          return "icon.global";
        case (name.substr(0, 8)) === "hashtag/":
          return "icon.hashtag";
        case (name.substr(0, 5)) === "user/":
          return "icon.user";
        case "notifications":
          return "icon.notifications";
        case "highlights":
          return "icon.favourite";
        default:
          return "icon.mystery";
      }
    },
    componentWillReceiveProps: function(nextProps) {
      if (this.props.name === nextProps.name) {
        return;
      }
      this.request.stop();
      this.request.removeEventListener("response", this.handleResponse);
      this.request = new Laboratory.Timeline.Request(this.getParams(nextProps.name));
      this.request.addEventListener("response", this.handleResponse);
      return this.request.start();
    },
    componentWillMount: function() {
      this.request = new Laboratory.Timeline.Request(this.getParams());
      this.request.addEventListener("response", this.handleResponse);
      return this.request.start();
    },
    componentWillUnmount: function() {
      this.request.stop();
      return this.request.removeEventListener("response", this.handleResponse);
    },
    render: function() {
      var post;
      return 彁(Columns.Column, (this.props.name === "notifications" ? {
        id: "labcoat-notifications"
      } : null), 彁(Columns.Heading, {
        icon: this.getIcon()
      }, 彁(ReactIntl.FormattedMessage, {
        id: "timeline." + this.props.name,
        defaultMessage: (this.props.name.charAt(0)).toLocaleUpperCase() + this.props.name.slice(1)
      })), this.state.timeline != null ? 彁.apply(null, ["div", {
        className: "labcoat-posts"
      }].concat(slice.call((function() {
        var j, len, ref1, results;
        ref1 = this.state.timeline.posts;
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          post = ref1[j];
          results.push(彁(Columns.Status, post));
        }
        return results;
      }).call(this)))) : null);
    }
  });

  Modules = {};

  Modules.Module = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      attributes: React.PropTypes.object,
      close: React.PropTypes.bool,
      closeTo: React.PropTypes.string
    },
    getInitialState: function() {
      return {
        shouldClose: this.props.close
      };
    },
    contextTypes: {
      router: React.PropTypes.object.isRequired
    },
    componentWillReceiveProps: function(nextProps) {
      if (!(nextProps.close && !this.state.shouldClose)) {
        return;
      }
      return this.close();
    },
    close: function() {
      this.setState({
        shouldClose: true
      });
      return window.setTimeout(((function(_this) {
        return function() {
          var ref1;
          if (_this.props.closeTo || ((ref1 = window.history) != null ? ref1.length : void 0) <= 1) {
            return _this.context.router.push(_this.props.closeTo || "/");
          } else {
            return _this.context.router.goBack();
          }
        };
      })(this)), 500);
    },
    render: function() {
      return 彁("div", (this.state.shouldClose ? {
        id: "labcoat-module",
        "data-labcoat-dismiss": ""
      } : {
        id: "labcoat-module"
      }), 彁("div", {
        id: "labcoat-curtain",
        onClick: this.close
      }), 彁("main", (this.props.attributes != null ? this.props.attributes : null), this.props.children));
    }
  });

  Modules.Account = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      id: React.PropTypes.number.isRequired,
      myID: React.PropTypes.number.isRequired
    },
    getInitialState: function() {
      return {
        account: null
      };
    },
    request: null,
    handleResponse: function(event) {
      return this.setState({
        account: event.detail.response
      });
    },
    componentWillReceiveProps: function(nextProps) {
      if (this.props.id === nextProps.id) {
        return;
      }
      this.request.stop();
      this.request.removeEventListener("response", this.handleResponse);
      this.request = new Laboratory.Profile.Request({
        id: nextProps.id
      });
      this.request.addEventListener("response", this.handleResponse);
      return this.request.start();
    },
    componentWillMount: function() {
      this.request = new Laboratory.Profile.Request({
        id: this.props.id
      });
      this.request.addEventListener("response", this.handleResponse);
      return this.request.start();
    },
    componentWillUnmount: function() {
      this.request.stop();
      return this.request.removeEventListener("response", this.handleResponse);
    },
    render: function() {
      if (this.state.account == null) {
        return null;
      }
      return 彁(Modules.Module, {
        attributes: {
          id: "labcoat-account"
        }
      }, 彁("header", {
        style: {
          backgroundImage: "url(" + this.state.account.header + ")"
        }
      }, 彁("a", {
        src: this.state.account.header,
        target: "_blank"
      })), 彁(Shared.IDCard, {
        account: this.state.account,
        externalLinks: true
      }), (function() {
        switch (false) {
          case !(this.state.account.relationship & Laboratory.Profile.Relationship.SELF):
            return null;
          case !(this.state.account.relationship & Laboratory.Profile.Relationship.FOLLOWING):
            return 彁(Shared.Button, {
              label: 彁(ReactIntl.FormattedMessage, {
                id: "account.unfollow",
                defaultMessage: "Unfollow"
              }),
              icon: "icon.unfollow"
            });
          case !(this.state.account.relationship & Laboratory.Profile.Relationship.BLOCKING):
            return 彁(Shared.Button, {
              label: 彁(ReactIntl.FormattedMessage, {
                id: "account.blocked",
                defaultMessage: "Blocked"
              }),
              icon: "icon.blocked",
              disabled: true
            });
          case !(this.state.account.relationship & Laboratory.Profile.Relationship.REQUESTED):
            return 彁(Shared.Button, {
              label: 彁(ReactIntl.FormattedMessage, {
                id: "account.requested",
                defaultMessage: "Request Sent"
              }),
              icon: "icon.requested",
              disabled: true
            });
          default:
            if (this.state.account.locked) {
              return 彁(Shared.Button, {
                label: 彁(ReactIntl.FormattedMessage, {
                  id: "account.request",
                  defaultMessage: "Request Follow"
                }),
                icon: "icon.request"
              });
            } else {
              return 彁(Shared.Button, {
                label: 彁(ReactIntl.FormattedMessage, {
                  id: "account.follow",
                  defaultMessage: "Follow"
                }),
                icon: "icon.follow"
              });
            }
        }
      }).call(this), 彁("p", {
        dangerouslySetInnerHTML: {
          __html: this.state.account.bio
        }
      }), 彁("footer", null, 彁("table", null, 彁("tbody", null, 彁("tr", null, 彁("td", null, 彁("b", null, this.state.account.statusCount), 彁(ReactIntl.FormattedMessage, {
        id: "account.statuses",
        defaultMessage: "Posts"
      })), 彁("td", null, 彁("b", null, this.state.account.followingCount), 彁(ReactIntl.FormattedMessage, {
        id: "account.following",
        defaultMessage: "Follows"
      })), 彁("td", null, 彁("b", null, this.state.account.followerCount), 彁(ReactIntl.FormattedMessage, {
        id: "account.followers",
        defaultMessage: "Followers"
      })))))));
    }
  });

  Modules.Composer = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      maxChars: React.PropTypes.number.isRequired,
      myID: React.PropTypes.number.isRequired,
      defaultPrivacy: React.PropTypes.string,
      visible: React.PropTypes.bool,
      text: React.PropTypes.string,
      inReplyTo: React.PropTypes.number
    },
    getDefaultProps: function() {
      return {
        text: "",
        inReplyTo: void 0
      };
    },
    profileRequest: null,
    postRequest: null,
    getInitialState: function() {
      return {
        account: null,
        replyStatus: null,
        text: this.props.text + "\n",
        inReplyTo: isFinite(this.props.inReplyTo) ? Number(this.props.inReplyTo) : void 0,
        message: "",
        charsLeft: this.props.maxChars,
        makePublic: this.props.defaultPrivacy !== "private",
        makeListed: this.props.defaultPrivacy === "public",
        makeNSFW: false,
        forceNSFW: true,
        useMessage: false,
        shouldClose: false
      };
    },
    contextTypes: {
      intl: React.PropTypes.object.isRequired
    },
    handleResponse: function(event) {
      var response;
      response = event.detail.response;
      switch (false) {
        case !(response instanceof Laboratory.Profile):
          this.setState({
            account: response
          });
          break;
        case !(response instanceof Laboratory.Post):
          this.setState({
            replyStatus: response
          });
      }
    },
    componentWillMount: function() {
      this.profileRequest = new Laboratory.Profile.Request({
        id: this.props.myID
      });
      this.profileRequest.addEventListener("response", this.handleResponse);
      this.profileRequest.start();
      if (isFinite(this.props.inReplyTo)) {
        this.postRequest = new Laboratory.Post.Request({
          id: this.props.inReplyTo,
          type: Laboratory.Post.Type.STATUS
        });
        this.postRequest.addEventListener("response", this.handleResponse);
        return this.postRequest.start();
      }
    },
    componentWillUnmount: function() {
      var j, len, ref1, request, results;
      ref1 = [this.profileRequest, this.postRequest];
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        request = ref1[j];
        if (!(request)) {
          continue;
        }
        request.stop();
        results.push(request.removeEventListener("response", this.handleResponse));
      }
      return results;
    },
    input: {
      textbox: null,
      message: null,
      makePublic: null,
      makeListed: null,
      makeNSFW: null,
      useMessage: null,
      post: null
    },
    componentWillReceiveProps: function(nextProps) {
      if (!this.props.visible && nextProps.visible) {
        this.setState({
          shouldClose: false
        });
      }
      if (nextProps.inReplyTo !== this.props.inReplyTo) {
        if (this.postRequest != null) {
          this.postRequest.stop();
          this.postRequest.removeEventListener("response", this.handleResponse);
          this.postRequest = void 0;
        }
        if (isFinite(nextProps.inReplyTo)) {
          this.postRequest = new Laboratory.Post.Request({
            id: nextProps.inReplyTo,
            type: Laboratory.Post.Type.STATUS
          });
          this.postRequest.addEventListener("response", this.handleResponse);
          this.postRequest.start();
        }
      }
      if (nextProps.text !== this.props.text) {
        this.setState({
          text: nextProps.text + "\n"
        });
      }
      if ((isFinite(nextProps.inReplyTo)) && nextProps.inReplyTo !== this.props.inReplyTo) {
        return this.setState({
          inReplyTo: Number(nextProps.inReplyTo)
        });
      }
    },
    getCharsLeft: function() {
      return this.charsLeft = this.props.maxChars - ((this.input.textbox.value + this.input.message.value).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_")).length + 1;
    },
    format: function(text) {
      var i, j, lines, ref1, result;
      result = document.createElement("div");
      lines = text.split("\n");
      for (i = j = 0, ref1 = lines.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
        if (lines[i]) {
          result.appendChild(document.createTextNode(lines[i]));
        }
        if (i !== lines.length - 1 || lines[i]) {
          result.appendChild(document.createElement("br"));
        }
      }
      return result.innerHTML;
    },
    handleEvent: function(event) {
      switch (event.type) {
        case "change":
          switch (event.target) {
            case this.input.message:
              return this.setState({
                message: this.input.message.value,
                charsLeft: this.getCharsLeft()
              });
            case this.input.makePublic:
              return this.setState({
                makePublic: this.input.makePublic.checked,
                makeListed: this.input.makeListed.checked && this.input.makePublic.checked,
                forceListed: !this.input.makePublic.checked
              });
            case this.input.makeListed:
              return this.setState({
                makePublic: this.input.makePublic.checked || this.input.makeListed.checked,
                makeListed: this.input.makeListed.checked
              });
            case this.input.makeNSFW:
              return this.setState({
                makeNSFW: event.target.checked
              });
            case this.input.useMessage:
              return this.setState({
                useMessage: event.target.checked
              });
          }
          break;
        case "click":
          if (event.target === this.input.post && this.getCharsLeft() >= 0) {
            (new Laboratory.Post.Create({
              text: this.state.text,
              message: this.state.useMessage ? this.state.message : null,
              visibility: (function() {
                switch (false) {
                  case !this.state.makeListed:
                    return Laboratory.Post.Visibility.PUBLIC;
                  case !this.state.makePublic:
                    return Laboratory.Post.Visibility.UNLISTED;
                  default:
                    return Laboratory.Post.Visibility.IN_HOME;
                }
              }).call(this),
              makeNSFW: this.state.makeNSFW,
              inReplyTo: this.state.inReplyTo
            })).start();
            return this.setState({
              replyStatus: null,
              text: "\n",
              message: "",
              inReplyTo: void 0,
              charsLeft: this.props.maxChars,
              useMessage: false,
              makeNSFW: false,
              forceNSFW: true,
              shouldClose: true
            });
          }
      }
    },
    render: function() {
      var ref1;
      if (!(this.props.visible && (!this.state.inReplyTo || ((ref1 = this.state.replyStatus) != null ? ref1.id : void 0) === this.state.inReplyTo))) {
        return null;
      }
      return 彁(Modules.Module, {
        attributes: {
          id: "labcoat-composer"
        },
        close: this.state.shouldClose
      }, 彁("header", null, this.state.account ? 彁(Shared.IDCard, {
        account: this.state.account
      }) : null), 彁(Shared.Textbox, {
        id: "labcoat-composertextbox",
        "aria-label": this.context.intl.messages["composer.placeholder"],
        onChange: ((function(_this) {
          return function(text) {
            return _this.setState({
              text: text,
              charsLeft: _this.getCharsLeft()
            });
          };
        })(this)),
        value: this.format(this.state.text),
        ref: ((function(_this) {
          return function(ref) {
            return _this.input.textbox = ref;
          };
        })(this))
      }), 彁("footer", null, 彁("span", {
        id: "labcoat-count"
      }, isNaN(this.state.charsLeft) ? "" : this.state.charsLeft), 彁(Shared.Button, {
        onClick: this.handleEvent,
        getRef: ((function(_this) {
          return function(ref) {
            return _this.input.post = ref;
          };
        })(this)),
        disabled: this.state.charsLeft < 0,
        label: 彁(ReactIntl.FormattedMessage, {
          id: "composer.post",
          defaultMessage: "Post"
        }),
        icon: "icon.post"
      })), 彁("aside", {
        id: "labcoat-composeroptions"
      }, 彁("div", {
        id: "labcoat-postoptions"
      }, 彁(Shared.Toggle, {
        getRef: (function(_this) {
          return function(ref) {
            return _this.input.makePublic = ref;
          };
        })(this),
        checked: this.state.makePublic,
        onChange: this.handleEvent,
        inactiveText: 彁(ReactIntl.FormattedMessage, {
          id: "composer.private",
          defaultMessage: "Private"
        }),
        inactiveIcon: "icon.private",
        activeIcon: "icon.public",
        activeText: 彁(ReactIntl.FormattedMessage, {
          id: "composer.public",
          defaultMessage: "Public"
        })
      }), 彁(Shared.Toggle, {
        getRef: (function(_this) {
          return function(ref) {
            return _this.input.makeListed = ref;
          };
        })(this),
        checked: this.state.makeListed,
        onChange: this.handleEvent,
        inactiveText: 彁(ReactIntl.FormattedMessage, {
          id: "composer.unlisted",
          defaultMessage: "Unlisted"
        }),
        inactiveIcon: "icon.unlisted",
        activeIcon: "icon.listed",
        activeText: 彁(ReactIntl.FormattedMessage, {
          id: "composer.listed",
          defaultMessage: "Listed"
        })
      }), 彁(Shared.Toggle, {
        getRef: (function(_this) {
          return function(ref) {
            return _this.input.makeNSFW = ref;
          };
        })(this),
        checked: this.state.makeNSFW,
        onChange: this.handleEvent,
        disabled: this.state.forceNSFW,
        inactiveText: 彁(ReactIntl.FormattedMessage, {
          id: "composer.sfw",
          defaultMessage: "Safe"
        }),
        inactiveIcon: "icon.sfw",
        activeIcon: "icon.nsfw",
        activeText: 彁(ReactIntl.FormattedMessage, {
          id: "composer.nsfw",
          defaultMessage: "Sensitive"
        })
      })), 彁("div", {
        id: "labcoat-hideoptions"
      }, 彁(Shared.Toggle, {
        getRef: (function(_this) {
          return function(ref) {
            return _this.input.useMessage = ref;
          };
        })(this),
        checked: this.state.useMessage,
        onChange: this.handleEvent,
        inactiveText: "",
        inactiveIcon: "icon.nomessage",
        activeIcon: "icon.message",
        activeText: 彁(ReactIntl.FormattedMessage, {
          id: "composer.message",
          defaultMessage: "Hide behind message"
        })
      }), 彁("input", {
        type: "text",
        placeholder: this.context.intl.messages["composer.nomessage"],
        value: this.state.message,
        ref: (function(_this) {
          return function(ref) {
            return _this.input.message = ref;
          };
        })(this),
        onChange: this.handleEvent
      }))));
    }
  });

  Shared = {};

  Shared.Action = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      active: React.PropTypes.bool,
      icon: React.PropTypes.string.isRequired,
      label: React.PropTypes.oneOfType([React.PropTypes.element, React.PropTypes.string]),
      getRef: React.PropTypes.func,
      className: React.PropTypes.string,
      action: React.PropTypes.func
    },
    getDefaultProps: function() {
      return {
        active: false,
        label: "",
        action: function() {}
      };
    },
    action: null,
    componentDidMount: function() {
      if (this.props.getRef) {
        return this.props.getRef(this.action);
      }
    },
    render: function() {
      var key, output_props, ref1, val;
      output_props = {
        className: "labcoat-action",
        ref: (function(_this) {
          return function(ref) {
            return _this.action = ref;
          };
        })(this)
      };
      ref1 = this.props;
      for (key in ref1) {
        if (!hasProp.call(ref1, key)) continue;
        val = ref1[key];
        if ((["className", "getRef", "ref", "label", "icon", "containerClass"].indexOf(key)) === -1) {
          output_props[key] = val;
        }
      }
      return 彁("label", {
        className: "labcoat-actioncontainer" + (this.props.className ? " " + this.props.className : "") + (this.props.disabled ? " labcoat-actioncontainer--disabled" : "") + (this.props.active ? " labcoat-actioncontainer--active" : ""),
        onClick: this.props.action
      }, this.props.label, 彁("button", output_props, 彁(Shared.Icon, {
        name: this.props.icon
      })));
    }
  });

  Shared.Button = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      icon: React.PropTypes.string.isRequired,
      label: React.PropTypes.oneOfType([React.PropTypes.element, React.PropTypes.string]),
      getRef: React.PropTypes.func,
      containerClass: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        label: ""
      };
    },
    button: null,
    componentDidMount: function() {
      if (this.props.getRef) {
        return this.props.getRef(this.button);
      }
    },
    render: function() {
      var key, output_props, ref1, val;
      output_props = {
        className: "labcoat-button",
        ref: (function(_this) {
          return function(ref) {
            return _this.button = ref;
          };
        })(this)
      };
      ref1 = this.props;
      for (key in ref1) {
        if (!hasProp.call(ref1, key)) continue;
        val = ref1[key];
        if (key === "className") {
          output_props[key] += " " + val;
        } else if ((["getRef", "ref", "label", "icon", "containerClass"].indexOf(key)) === -1) {
          output_props[key] = val;
        }
      }
      return 彁("label", {
        className: "labcoat-buttoncontainer" + (this.props.containerClass ? " " + this.props.containerClass : "") + (this.props.disabled ? " labcoat-buttoncontainer--disabled" : "")
      }, this.props.label, 彁("button", output_props, 彁(Shared.Icon, {
        name: this.props.icon
      })));
    }
  });

  Shared.Icon = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      name: React.PropTypes.string.isRequired
    },
    contextTypes: {
      intl: React.PropTypes.object.isRequired
    },
    render: function() {
      return 彁('i', {
        className: "fa fa-fw fa-" + (this.context.intl.messages[this.props.name] || this.props.name),
        "aria-hidden": true
      });
    }
  });

  Shared.IDCard = function(props) {
    if (!(props.account instanceof Object)) {
      return null;
    }
    return 彁('div', {
      className: "labcoat-idcard"
    }, 彁.apply(null, slice.call((props.externalLinks ? [
      "a", {
        href: props.account.avatar,
        target: "_blank"
      }
    ] : [
      ReactRouter.Link, {
        to: "user/" + props.account.id,
        title: props.account.displayName
      }
    ])).concat([彁('img', {
      className: "labcoat-avatar",
      src: props.account.avatar,
      alt: props.account.displayName
    })])), 彁.apply(null, slice.call((props.externalLinks ? [
      "a", {
        href: props.account.href,
        title: props.account.displayName,
        target: "_blank"
      }
    ] : [
      ReactRouter.Link, {
        to: "user/" + props.account.id,
        title: props.account.displayName
      }
    ])).concat([彁('b', {
      className: "labcoat-displayname"
    }, props.account.displayName)], [彁('code', {
      className: "labcoat-username"
    }, props.account.localAccount)])));
  };

  Shared.IDCard.propTypes = {
    account: React.PropTypes.object.isRequired,
    externalLinks: React.PropTypes.bool
  };

  Shared.Textbox = React.createClass({
    propTypes: {
      getRef: React.PropTypes.func,
      onChange: React.PropTypes.func,
      className: React.PropTypes.string,
      id: React.PropTypes.string,
      'aria-label': React.PropTypes.string,
      value: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        value: "<br>"
      };
    },
    componentDidMount: function() {
      if (this.props.getRef != null) {
        this.props.getRef(this.input);
      }
      return this.value = this.getContents();
    },
    caret: 0,
    value: "\n",
    handleEvent: function(event) {
      var br, rng, sel;
      if (!((event.type === "input" || event.type === "blur" || event.type === "keypress") && event.target === this.input)) {
        return;
      }
      if (event.type === "keypress") {
        if (event.key === "Enter" || event.code === "Enter" || event.keyCode === 0x0D) {
          event.preventDefault();
          sel = window.getSelection();
          rng = sel.getRangeAt(0);
          rng.deleteContents();
          rng.insertNode(br = document.createElement("br"));
          rng.setEndAfter(br);
          rng.collapse(false);
          sel.removeAllRanges();
          sel.addRange(rng);
        } else {
          return;
        }
      }
      this.value = this.getContents();
      if (this.props.onChange) {
        return this.props.onChange(this.value);
      }
    },
    getContents: function() {
      var nde, out, wkr;
      wkr = document.createTreeWalker(this.input);
      nde = null;
      out = "";
      while ((wkr.nextNode()) != null) {
        nde = wkr.currentNode;
        if (nde.nodeType === Node.TEXT_NODE) {
          out += nde.textContent;
        } else if (nde.nodeType === Node.ELEMENT_NODE && nde.tagName.toUpperCase() === "BR") {
          out += "\n";
        }
      }
      if (out.length && (out.slice(-1)) !== "\n") {
        out += "\n";
      }
      return out;
    },
    shouldComponentUpdate: function(nextProps, nextState) {
      return this.props.value !== this.input.innerHTML;
    },
    updateCaretPos: function() {
      var brs, pre, rng, sel;
      this.caret = 0;
      sel = window.getSelection();
      rng = sel.getRangeAt(0);
      pre = rng.cloneRange();
      pre.selectNodeContents(this.input);
      pre.setEnd(rng.endContainer, rng.endOffset);
      brs = ((pre.cloneContents()).querySelectorAll("br")).length;
      this.caret = (pre.toString()).length + brs;
      pre.detach();
    },
    componentWillUpdate: function() {
      return this.updateCaretPos();
    },
    componentDidUpdate: function() {
      var idx, nde, ref1, ref2, rng, sel, success, wkr;
      sel = window.getSelection();
      rng = document.createRange();
      wkr = document.createTreeWalker(this.input);
      idx = 0;
      nde = null;
      success = false;
      if (this.caret >= this.value.length - 1) {
        success = true;
      }
      while (true) {
        if ((wkr.nextNode()) == null) {
          break;
        }
        nde = wkr.currentNode;
        if (nde.nodeType === Node.TEXT_NODE) {
          if ((idx <= (ref1 = this.caret) && ref1 <= idx + nde.textContent.length)) {
            success = true;
            break;
          } else {
            idx += nde.textContent.length;
          }
        } else if (nde.nodeType === Node.ELEMENT_NODE && nde.tagName.toUpperCase() === "BR") {
          if (idx++ === this.caret) {
            success = true;
            break;
          }
        } else {
          continue;
        }
      }
      if (success && nde) {
        if (nde.nodeType === Node.TEXT_NODE) {
          rng.setEnd(nde, this.caret - idx);
        } else {
          rng.selectNodeContents(nde);
        }
      } else if (((ref2 = this.input.lastChild) != null ? ref2.nodeName.toUpperCase : void 0) === "BR") {
        rng.setEnd(this.input, this.input.childNodes.length - 1);
      } else {
        rng.selectNodeContents(this.input);
      }
      rng.collapse(false);
      sel.removeAllRanges();
      return sel.addRange(rng);
    },
    render: function() {
      var key, output_props, ref1, value;
      output_props = {
        className: "labcoat-textbox" + (this.props.value.toLowerCase() === "<br>" || this.props.value === "\n" || this.props.value === "" ? " labcoat-textbox--empty" : "") + (this.props.className != null ? " " + this.props.className : ""),
        contentEditable: true,
        onKeyPress: this.handleEvent,
        onInput: this.handleEvent,
        onBlur: this.handleEvent,
        ref: (function(_this) {
          return function(ref) {
            return _this.input = ref;
          };
        })(this),
        dangerouslySetInnerHTML: {
          __html: this.props.value
        }
      };
      ref1 = this.props;
      for (key in ref1) {
        if (!hasProp.call(ref1, key)) continue;
        value = ref1[key];
        if ((["className", "contentEditable", "value", "getRef", "onChange", "onInput", "onBlur", "dangerouslySetInnerHTML", "ref"].indexOf(key)) === -1) {
          output_props[key] = value;
        }
      }
      return 彁("div", output_props);
    }
  });

  Shared.Toggle = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      checked: React.PropTypes.bool,
      disabled: React.PropTypes.bool,
      onChange: React.PropTypes.func,
      className: React.PropTypes.string,
      name: React.PropTypes.string,
      value: React.PropTypes.string,
      id: React.PropTypes.string,
      'aria-labelledby': React.PropTypes.string,
      'aria-label': React.PropTypes.string,
      getRef: React.PropTypes.func,
      activeText: React.PropTypes.oneOfType([React.PropTypes.element, React.PropTypes.string]),
      inactiveText: React.PropTypes.oneOfType([React.PropTypes.element, React.PropTypes.string]),
      activeicon: React.PropTypes.string,
      inactiveicon: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        activeText: 彁(ReactIntl.FormattedMessage, {
          id: "toggle.on",
          defaultMessage: "On"
        }),
        inactiveText: 彁(ReactIntl.FormattedMessage, {
          id: "toggle.off",
          defaultMessage: "Off"
        }),
        activeIcon: "icon.on",
        inactiveIcon: "icon.off"
      };
    },
    getInitialState: function() {
      return {
        checked: !!this.props.checked,
        disabled: !!this.props.disabled,
        hasFocus: false
      };
    },
    componentWillReceiveProps: function(nextProps) {
      if (nextProps.checked != null) {
        this.setState({
          checked: !!nextProps.checked
        });
      }
      if (nextProps.disabled != null) {
        this.setState({
          disabled: !!nextProps.disabled
        });
      }
    },
    componentDidMount: function() {
      if (this.props.getRef != null) {
        return this.props.getRef(this.input);
      }
    },
    handleEvent: function(event) {
      switch (event.type) {
        case "click":
          if (event.target !== this.input) {
            event.preventDefault();
            this.input.focus();
            this.input.click();
          }
          return this.setState({
            checked: this.input.checked
          });
        case "onFocus":
          this.setState({
            hasFocus: true
          });
          if (this.props.onFocus) {
            return this.props.onFocus(event);
          }
          break;
        case "onBlur":
          this.setState({
            hasFocus: false
          });
          if (this.props.onBlur) {
            return this.props.onBlur(event);
          }
      }
    },
    render: function() {
      var key, output_props, ref1, value;
      output_props = {
        className: "labcoat-toggle-screenreader-only",
        type: "checkbox",
        onFocus: this.handleEvent,
        onBlur: this.handleEvent,
        ref: (function(_this) {
          return function(ref) {
            return _this.input = ref;
          };
        })(this)
      };
      ref1 = this.props;
      for (key in ref1) {
        if (!hasProp.call(ref1, key)) continue;
        value = ref1[key];
        if ((["className", "activeText", "activeIcon", "inactiveText", "inactiveIcon", "getRef", "ref", "type", "onFocus", "onBlur"].indexOf(key)) === -1) {
          output_props[key] = value;
        }
      }
      return 彁("label", {
        className: "labcoat-toggle" + (this.state.checked ? " labcoat-toggle--checked" : "") + (this.state.disabled ? " labcoat-toggle--disabled" : "") + (this.state.hasFocus ? " labcoat-toggle--focus" : "") + (this.props.className ? " " + this.props.className : ""),
        onClick: this.handleEvent
      }, 彁("span", {
        className: "labcoat-toggle-label labcoat-toggle-label-off"
      }, this.props.inactiveText), 彁("div", {
        className: "labcoat-toggle-track"
      }, 彁("div", {
        className: "labcoat-toggle-track-check"
      }, 彁(Shared.Icon, {
        name: this.props.activeIcon
      })), 彁("div", {
        className: "labcoat-toggle-track-x"
      }, 彁(Shared.Icon, {
        name: this.props.inactiveIcon
      })), 彁("div", {
        className: "labcoat-toggle-thumb"
      }), 彁("input", output_props)), 彁("span", {
        className: "labcoat-toggle-label labcoat-toggle-label-on"
      }, this.props.activeText));
    }
  });

  Shared.InstanceQuery = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      locale: React.PropTypes.string.isRequired,
      title: React.PropTypes.string,
      basename: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        title: "Labcoat",
        basename: "/web"
      };
    },
    getInitialState: function() {
      return {
        value: ""
      };
    },
    input: null,
    handleEvent: function(event) {
      if (event.type === "change" && event.target === this.input) {
        this.setState({
          value: this.input.value
        });
      } else if (event.type === "keypress" && event.target === this.input && (event.key === "Enter" || event.code === "Enter" || event.keyCode === 0x0D) && this.input.value.length && this.input.validity.valid) {
        (new Laboratory.Authorization.Request({
          name: this.props.title,
          origin: "https://" + this.input.value,
          redirect: this.props.basename,
          scope: Laboratory.Authorization.Scope.READWRITEFOLLOW
        })).start(window.open("about:blank", "LaboratoryOAuth"));
        this.setState({
          value: ""
        });
      }
    },
    render: function() {
      return 彁(ReactIntl.IntlProvider, {
        locale: this.props.locale,
        messages: Locales[this.props.locale]
      }, 彁("div", {
        id: "labcoat-instancequery"
      }, 彁(ReactIntl.FormattedMessage, {
        id: "instancequery.queryinstance",
        defaultMessage: "What's your instance?"
      }), 彁("div", {
        id: "labcoat-instancequeryinput"
      }, 彁("code", {
        className: "labcoat-username"
      }, "username@"), 彁("input", {
        type: "text",
        pattern: "[0-9A-Za-z\-\.]+(\:[0-9]{1,4})?",
        placeholder: "example.com",
        value: this.state.value,
        ref: (function(_this) {
          return function(ref) {
            return _this.input = ref;
          };
        })(this),
        onChange: this.handleEvent,
        onKeyPress: this.handleEvent
      }))));
    }
  });

  Router = ReactRouter.Router, Route = ReactRouter.Route, IndexRoute = ReactRouter.IndexRoute;

  Shared.Frontend = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      locale: React.PropTypes.string.isRequired,
      myID: React.PropTypes.number.isRequired,
      title: React.PropTypes.string,
      links: React.PropTypes.object,
      basename: React.PropTypes.string,
      maxChars: React.PropTypes.number,
      useBrowserHistory: React.PropTypes.bool,
      defaultPrivacy: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        title: "Labcoat",
        basename: "/web",
        maxChars: 500,
        defaultPrivacy: "unlisted",
        useBrowserHistory: true
      };
    },
    getInitialState: function() {
      return {
        thirdColumn: 彁(Columns.Empty),
        showComposer: false,
        composerQuery: null
      };
    },
    setThirdColumn: function(component, props) {
      return this.setState({
        thirdColumn: 彁(component, props)
      });
    },
    getThirdColumn: function() {
      return this.state.thirdColumn;
    },
    showComposer: function(nextState) {
      return this.setState({
        showComposer: true,
        composerQuery: nextState.location.query || null
      });
    },
    hideComposer: function() {
      return this.setState({
        showComposer: false,
        composerQuery: null
      });
    },
    componentWillMount: function() {
      this.history = (this.props.useBrowserHistory ? ReactRouter.useRouterHistory(History.createHistory) : ReactRouter.useRouterHistory(History.createHashHistory))({
        basename: this.props.basename
      });
      this.routes = 彁(Route, {
        path: '/',
        component: (function(_this) {
          return function(props) {
            return 彁(UI.UI, {
              title: _this.props.title,
              maxChars: _this.props.maxChars,
              defaultPrivacy: _this.props.defaultPrivacy,
              thirdColumn: _this.getThirdColumn(),
              myID: _this.props.myID,
              showComposer: _this.state.showComposer,
              composerQuery: _this.state.composerQuery
            }, props.children);
          };
        })(this)
      }, 彁(IndexRoute, {
        onEnter: (function(_this) {
          return function() {
            return _this.setThirdColumn(Columns.Go, {
              footerLinks: _this.props.links,
              myID: _this.props.myID
            });
          };
        })(this)
      }), 彁(Route, {
        path: 'start',
        onEnter: (function(_this) {
          return function() {
            return _this.setThirdColumn(Modules.Start);
          };
        })(this)
      }), 彁(Route, {
        path: 'global',
        onEnter: (function(_this) {
          return function() {
            return _this.setThirdColumn(Columns.Timeline, {
              name: 'global'
            });
          };
        })(this)
      }), 彁(Route, {
        path: 'community',
        onEnter: (function(_this) {
          return function() {
            return _this.setThirdColumn(Columns.Timeline, {
              name: 'community'
            });
          };
        })(this)
      }), 彁(Route, {
        path: 'hashtag/:id',
        onEnter: (function(_this) {
          return function(nextState) {
            return _this.setThirdColumn(Columns.Timeline, {
              name: 'hashtag/' + nextState.params.id
            });
          };
        })(this)
      }), 彁(Route, {
        path: 'favourites',
        onEnter: (function(_this) {
          return function() {
            return _this.setThirdColumn(Columns.Timeline, {
              name: 'favourites'
            });
          };
        })(this)
      }), 彁(Route, {
        path: 'compose(?**)',
        onEnter: ((function(_this) {
          return function(nextState) {
            return _this.showComposer(nextState);
          };
        })(this)),
        onLeave: (function(_this) {
          return function() {
            return _this.hideComposer();
          };
        })(this)
      }), 彁(Route, {
        path: 'post/:id',
        component: Modules.Post
      }), 彁(Route, {
        path: 'user/:id',
        component: (function(_this) {
          return function(props) {
            return 彁(Modules.Account, {
              id: Number(props.params.id),
              myID: _this.props.myID
            });
          };
        })(this)
      }), 彁(Route, {
        path: 'user/:id/posts',
        onEnter: (function(_this) {
          return function(nextState) {
            return _this.setThirdColumn(Columns.Timeline, {
              name: 'user/' + nextState.params.id
            });
          };
        })(this)
      }), 彁(Route, {
        path: '*',
        onEnter: (function(_this) {
          return function() {
            return _this.setThirdColumn(Columns.NotFound);
          };
        })(this)
      }));
    },
    componentWillUnmount: function() {
      if (this.subscription != null) {
        this.subscription.close();
        this.subscription = void 0;
      }
    },
    render: function() {
      return 彁(ReactIntl.IntlProvider, {
        locale: this.props.locale,
        messages: Locales[this.props.locale]
      }, 彁(Router, {
        history: this.history
      }, this.routes));
    }
  });

  UI = {};

  UI.Header = function(props) {
    return 彁('header', {
      id: "labcoat-header"
    }, 彁(UI.Title, null, props.title), 彁(ReactRouter.Link, {
      to: "/compose"
    }, 彁(Shared.Button, {
      icon: "icon.compose",
      label: 彁(ReactIntl.FormattedMessage, {
        id: "composer.compose",
        defaultMessage: "Compose"
      })
    })));
  };

  UI.Header.propTypes = {
    title: React.PropTypes.string
  };

  UI.Title = function(props) {
    return 彁('h1', null, 彁(ReactRouter.Link, {
      to: "/"
    }, props.children));
  };

  UI.UI = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      title: React.PropTypes.string,
      maxChars: React.PropTypes.number.isRequired,
      myID: React.PropTypes.number.isRequired,
      thirdColumn: React.PropTypes.element.isRequired,
      showComposer: React.PropTypes.bool,
      composerQuery: React.PropTypes.object
    },
    handleEvent: function(e) {
      switch (e.type) {
        case "dragenter":
          return (document.getElementById("labcoat-ui")).setAttribute("data-laboratory-dragging", "");
        case "dragover":
          e.preventDefault();
          return e.dataTransfer.dropEffect = "copy";
        case "dragleave":
          if (e.relatedTarget == null) {
            return (document.getElementById("labcoat-ui")).removeAttribute("data-laboratory-dragging");
          }
          break;
        case "drop":
          e.preventDefault();
          return (document.getElementById("labcoat-ui")).removeAttribute("data-laboratory-dragging");
      }
    },
    componentWillMount: function() {
      document.addEventListener("dragenter", this);
      document.addEventListener("dragover", this);
      document.addEventListener("dragleave", this);
      return document.addEventListener("drop", this);
    },
    componentWillUnmount: function() {
      document.removeEventListener("dragenter", this);
      document.removeEventListener("dragover", this);
      document.removeEventListener("dragleave", this);
      return document.removeEventListener("drop", this);
    },
    render: function() {
      var ref1, ref2;
      return 彁('div', {
        id: "labcoat-ui"
      }, 彁(UI.Header, {
        title: this.props.title
      }), 彁(Columns.Timeline, {
        name: "home"
      }), 彁(Columns.Timeline, {
        name: "notifications"
      }), this.props.thirdColumn, this.props.children, 彁(Modules.Composer, {
        defaultPrivacy: this.props.defaultPrivacy,
        myID: this.props.myID,
        maxChars: this.props.maxChars,
        visible: this.props.showComposer,
        text: (ref1 = this.props.composerQuery) != null ? ref1.text : void 0,
        inReplyTo: isFinite((ref2 = this.props.composerQuery) != null ? ref2.inReplyTo : void 0) ? Number(this.props.composerQuery.inReplyTo) : void 0
      }));
    }
  });

  Locales = {};

  Locales.en = {
    "timeline.home": "Home",
    "timeline.community": "Community",
    "timeline.global": "Global",
    "timeline.notifications": "Notifications",
    "composer.compose": "Compose",
    "composer.post": "Post",
    "composer.private": "Private",
    "composer.public": "Public",
    "composer.unlisted": "Unlisted",
    "composer.listed": "Listed",
    "composer.sfw": "Safe",
    "composer.nsfw": "Sensitive",
    "composer.nomessage": "…… ……",
    "composer.message": "Hide behind message",
    "composer.placeholder": "What's going on?",
    "account.follow": "Follow",
    "account.unfollow": "Unfollow",
    "account.blocking": "Blocking",
    "account.request": "Request Follow",
    "account.requested": "Request Sent",
    "account.statuses": "Posts",
    "account.following": "Follows",
    "account.followers": "Followers",
    "status.and": "and",
    "status.etal": "et al.",
    "status.reblog": "Boost",
    "status.unreblog": "Unboost",
    "status.noreblog": "Private",
    "status.favourite": "Highlight",
    "status.unfavourite": "Unhighlight",
    "status.reply": "Reply",
    "status.followedyou": "followed you!",
    "status.rebloggedthisreplyto": "boosted this reply to",
    "status.rebloggedthisreply": "boosted this reply",
    "status.rebloggedthisstatus": "boosted this post",
    "status.favouritedthisreplyto": "highlighted this reply to",
    "status.favouritedthisreply": "highlighted this reply",
    "status.favouritedthisstatus": "highlighted this post",
    "status.inreplyto": "In reply to",
    "status.inreplytoself": "In reply to themselves",
    "go.heading": "let's GO!",
    "go.profile": "Profile",
    "go.community": "Community",
    "go.global": "Global",
    "notfound.notfound": "Not found",
    "toggle.off": "Off",
    "toggle.on": "On",
    "icon.home": "home",
    "icon.community": "users",
    "icon.global": "link",
    "icon.hashtag": "hashtag",
    "icon.user": "at",
    "icon.notifications": "star-half-o",
    "icon.mystery": "question-circle",
    "icon.notfound": "exclamation-triangle",
    "icon.go": "arrow-right",
    "icon.profile": "list-alt",
    "icon.reblog": "plus-square",
    "icon.unreblog": "minus-square",
    "icon.noreblog": "square-o",
    "icon.favourite": "pencil",
    "icon.unfavourite": "eraser",
    "icon.reply": "reply",
    "icon.follow": "user-plus",
    "icon.unfollow": "user-times",
    "icon.blocked": "ban",
    "icon.request": "user-secret",
    "icon.requested": "share-square",
    "icon.post": "paper-plane-o",
    "icon.private": "microphone-slash",
    "icon.public": "rss",
    "icon.unlisted": "envelope-o",
    "icon.listed": "newspaper-o",
    "icon.sfw": "picture-o",
    "icon.nsfw": "exclamation",
    "icon.nomessage": "ellipsis-h",
    "icon.message": "question-circle-o",
    "icon.on": "check-circle-o",
    "icon.off": "times",
    "icon.compose": "pencil-square-o",
    "character.space": " ",
    "character.comma": ", "
  };

  Object.defineProperty(window, "Labcoat", {
    value: Object.freeze({
      "ℹ": "https://github.com/marrus-sh/labcoat",
      "Nº": 2.0
    }),
    enumerable: true
  });

  ReactIntl.addLocaleData(slice.call(ReactIntlLocaleData.en).concat(slice.call(ReactIntlLocaleData.de), slice.call(ReactIntlLocaleData.es), slice.call(ReactIntlLocaleData.fr), slice.call(ReactIntlLocaleData.pt), slice.call(ReactIntlLocaleData.hu), slice.call(ReactIntlLocaleData.uk)));

  window.addEventListener("load", function() {
    var INITIAL_STATE, config, data, elt, j, len, locale, message, prop, ref1, ref2, ref3, run, value;
    if ((elt = document.getElementById("labcoat-config")) && elt.tagName.toUpperCase() === "SCRIPT") {
      config = JSON.parse(elt.text);
    }
    if (config == null) {
      config = {};
    }
    if ((typeof INITIAL_STATE !== "undefined" && INITIAL_STATE !== null ? INITIAL_STATE.meta : void 0) == null) {
      INITIAL_STATE = {
        meta: {}
      };
    }
    ref1 = ["title", "basename", "useBrowserHistory", "locale", "root", "defaultPrivacy", "accessToken", "origin"];
    for (j = 0, len = ref1.length; j < len; j++) {
      prop = ref1[j];
      if (config[prop] == null) {
        config[prop] = {
          title: INITIAL_STATE.meta.title || "Labcoat",
          basename: INITIAL_STATE.meta.router_basename != null ? INITIAL_STATE.meta.router_basename : "/web",
          useBrowserHistory: INITIAL_STATE.meta.use_history || (INITIAL_STATE.meta.use_history == null),
          locale: INITIAL_STATE.meta.locale,
          root: INITIAL_STATE.meta.react_root,
          defaultPrivacy: ((ref2 = INITIAL_STATE.composer) != null ? ref2.default_privacy : void 0) || "unlisted",
          accessToken: INITIAL_STATE.meta.accessToken,
          origin: INITIAL_STATE.meta.origin || "/"
        }[prop];
      }
    }
    if (config.display != null) {
      if (indexOf.call(config.display, "simple") >= 0) {
        document.documentElement.setAttribute("data-labcoat-simple");
      } else {
        document.documentElement.removeAttribute("data-labcoat-simple");
      }
      if (indexOf.call(config.display, "no-transparency") >= 0) {
        document.documentElement.setAttribute("data-labcoat-no-transparency");
      } else {
        document.documentElement.removeAttribute("data-labcoat-no-transparency");
      }
      if (indexOf.call(config.display, "reduce-motion") >= 0) {
        document.documentElement.setAttribute("data-labcoat-reduce-motion");
      } else {
        document.documentElement.removeAttribute("data-labcoat-reduce-motion");
      }
    }
    ref3 = config.locales;
    for (locale in ref3) {
      data = ref3[locale];
      if (!(Locales[locale] instanceof Object)) {
        Locales[locale] = {};
      }
      for (message in data) {
        value = data[message];
        Locales[locale][message] = value;
      }
    }
    document.documentElement.setAttribute("lang", config.locale);
    run = function() {
      var callback;
      document.title = config.title;
      config.root = (function() {
        switch (false) {
          case !(config.root && (elt = document.getElementById(String(config.root)))):
            return elt;
          case !(elt = document.getElementById("frontend")):
            return elt;
          case !(elt = (document.getElementsByClassName("app-body")).item(0)):
            return elt;
          default:
            return document.body;
        }
      })();
      if (config.accessToken) {
        (new Laboratory.Authorization.Requested({
          accessToken: config.accessToken,
          origin: config.origin,
          scope: Authorization.Scope.READWRITEFOLLOW
        })).start();
      } else {
        ReactDOM.render(彁(Shared.InstanceQuery, {
          title: config.title,
          locale: config.locale,
          basename: config.basename
        }), config.root);
      }
      callback = function() {
        ReactDOM.unmountComponentAtNode(config.root);
        ReactDOM.render(彁(Shared.Frontend, {
          title: config.title,
          locale: config.locale,
          myID: Laboratory.auth.me,
          useBrowserHistory: config.useBrowserHistory,
          basename: config.basename,
          defaultPrivacy: config.defaultPrivacy
        }), config.root);
        return document.removeEventListener("LaboratoryAuthorizationReceived", callback);
      };
      document.addEventListener("LaboratoryAuthorizationReceived", callback);
      return document.removeEventListener("LaboratoryInitializationReady", run);
    };
    if (typeof Laboratory !== "undefined" && Laboratory !== null ? Laboratory.ready : void 0) {
      return run();
    } else {
      return document.addEventListener("LaboratoryInitializationReady", run);
    }
  });

}).call(this);
