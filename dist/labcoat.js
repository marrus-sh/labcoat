// Generated by CoffeeScript 1.12.4

/*

    ............... LABCOAT ................

     A client-side frontend for Mastodon, a
    free & open-source social network server
               - - by Kibigo! - -

        Licensed under the MIT License.
           Source code available at:
      https://github.com/marrus-sh/labcoat

                Version 0.1.0
 */

(function() {
  var Columns, INITIAL_STATE, IndexRoute, Locales, Modules, ReactPureRenderMixin, Route, Router, Shared, UI, config, j, len, prop, ref1, ref2, run,
    slice = [].slice,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Object.defineProperty(window, "彁", {
    value: React.createElement
  });

  if (typeof ReactPureRenderMixin === "undefined" || ReactPureRenderMixin === null) {
    ReactPureRenderMixin = React.addons.PureRenderMixin;
  }

  Columns = {};

  Columns.Column = function(props) {
    return 彁('div', (props.id != null ? {
      id: props.id,
      className: "laboratory-column"
    } : {
      className: "laboratory-column"
    }), props.children);
  };

  Columns.GoLink = function(props) {
    return 彁(ReactRouter.Link, {
      to: props.to,
      "aria-hidden": true
    }, 彁(Shared.Icon, {
      name: props.icon
    }), props.children);
  };

  Columns.GoLink.propTypes = {
    to: React.PropTypes.string.isRequired,
    icon: React.PropTypes.string.isRequired
  };

  Columns.Heading = function(props) {
    return 彁('h2', {
      className: "laboratory-heading"
    }, props.icon ? 彁(Shared.Icon, {
      name: props.icon
    }) : null, props.children);
  };

  Columns.Heading.propTypes = {
    icon: React.PropTypes.string
  };

  Columns.Status = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      id: React.PropTypes.number.isRequired,
      href: React.PropTypes.string,
      author: React.PropTypes.object,
      inReplyTo: React.PropTypes.number,
      content: React.PropTypes.string.isRequired,
      datetime: React.PropTypes.string,
      isReblogged: React.PropTypes.bool,
      isFavourited: React.PropTypes.bool,
      isNSFW: React.PropTypes.bool,
      message: React.PropTypes.string,
      visibility: React.PropTypes.string,
      mediaAttachments: React.PropTypes.array,
      mentions: React.PropTypes.array,
      rebloggedBy: React.PropTypes.object,
      favouritedBy: React.PropTypes.object,
      follower: React.PropTypes.object
    },
    getListOfMentions: function() {
      switch (this.props.mentions.length) {
        case 0:
          return [];
        case 1:
          return [
            彁(ReactRouter.Link, {
              to: "/user/" + this.props.mentions[0].id
            }, 彁("code", {
              className: "laboratory-username"
            }, this.props.mentions[0].username))
          ];
        case 2:
          return [
            彁(ReactRouter.Link, {
              to: "/user/" + this.props.mentions[0].id
            }, 彁("code", {
              className: "laboratory-username"
            }, this.props.mentions[0].username)), 彁(ReactIntl.FormattedMessage, {
              id: "status.and",
              message: " and "
            }), 彁(ReactRouter.Link, {
              to: "/user/" + this.props.mentions[1].id
            }, 彁("code", {
              className: "laboratory-username"
            }, this.props.mentions[1].username))
          ];
        case 3:
          return [
            彁(ReactRouter.Link, {
              to: "/user/" + this.props.mentions[0].id
            }, 彁("code", {
              className: "laboratory-username"
            }, this.props.mentions[0].username)), ", ", 彁(ReactRouter.Link, {
              to: "/user/" + this.props.mentions[1].id
            }, 彁("code", {
              className: "laboratory-username"
            }, this.props.mentions[1].username)), ", ", 彁(ReactIntl.FormattedMessage, {
              id: "status.and",
              message: " and "
            }), 彁(ReactRouter.Link, {
              to: "/user/" + this.props.mentions[2].id
            }, 彁("code", {
              className: "laboratory-username"
            }, this.props.mentions[2].username))
          ];
        default:
          return [
            彁(ReactRouter.Link, {
              to: "/user/" + this.props.mentions[0].id
            }, 彁("code", {
              className: "laboratory-username"
            }, this.props.mentions[0].username)), 彁(ReactIntl.FormattedMessage, {
              id: "status.etal",
              message: " et al."
            })
          ];
      }
    },
    render: function() {
      if (this.props.follower) {
        return 彁("article", {
          className: "laboratory-status"
        }, 彁(Shared.IDCard, {
          account: this.props.follower
        }), 彁(ReactIntl.FormattedMessage, {
          id: "status.followedyou",
          message: " followed you!"
        }));
      } else {
        return 彁("article", {
          className: "laboratory-status" + (this.props.isFavourited ? " laboratory-status--highlighted" : "")
        }, (this.props.rebloggedBy != null) || (this.props.favouritedBy != null) || (this.props.inReplyTo != null) ? 彁.apply(null, ["aside", null].concat(slice.call(((function() {
          var ref1, ref2, ref3;
          switch (false) {
            case !((this.props.inReplyTo != null) && (this.props.rebloggedBy != null)):
              return [彁(ReactRouter.Link, {
                  to: "/user/" + this.props.rebloggedBy.id
                }, 彁("code", {
                  className: "laboratory-username"
                }, this.props.rebloggedBy.username))].concat(slice.call((((ref1 = this.props.mentions) != null ? ref1.length : void 0) ? [彁(ReactIntl.FormattedMessage, {
                    id: "status.boostedthisreplyto",
                    message: " boosted this reply to "
                  })].concat(slice.call(this.getListOfMentions())) : [
                  彁(ReactIntl.FormattedMessage, {
                    id: "status.boostedthisreply",
                    message: " boosted this reply"
                  })
                ])));
            case !((this.props.inReplyTo != null) && (this.props.favouritedBy != null)):
              return [彁(ReactRouter.Link, {
                  to: "/user/" + this.props.favouritedBy.id
                }, 彁("code", {
                  className: "laboratory-username"
                }, this.props.favouritedBy.username))].concat(slice.call((((ref2 = this.props.mentions) != null ? ref2.length : void 0) ? [彁(ReactIntl.FormattedMessage, {
                    id: "status.highlightedthisreplyto",
                    message: " highlighted this reply to "
                  })].concat(slice.call(this.getListOfMentions())) : [
                  彁(ReactIntl.FormattedMessage, {
                    id: "status.highlightedthisreply",
                    message: " highlighted this reply"
                  })
                ])));
            case this.props.rebloggedBy == null:
              return [
                彁(ReactRouter.Link, {
                  to: "/user/" + this.props.rebloggedBy.id
                }, 彁("code", {
                  className: "laboratory-username"
                }, this.props.rebloggedBy.username)), 彁(ReactIntl.FormattedMessage, {
                  id: "status.boostedthispost",
                  message: " boosted this post"
                })
              ];
            case this.props.favouritedBy == null:
              return [
                彁(ReactRouter.Link, {
                  to: "/user/" + this.props.favouritedBy.id
                }, 彁("code", {
                  className: "laboratory-username"
                }, this.props.favouritedBy.username)), 彁(ReactIntl.FormattedMessage, {
                  id: "status.highlightedthispost",
                  message: " highlighted this post"
                })
              ];
            case this.props.inReplyTo == null:
              if ((ref3 = this.props.mentions) != null ? ref3.length : void 0) {
                return [彁(ReactIntl.FormattedMessage, {
                    id: "status.inreplyto",
                    message: "In reply to "
                  })].concat(slice.call(this.getListOfMentions()));
              } else {
                return [
                  彁(ReactIntl.FormattedMessage, {
                    id: "status.inreplytoself",
                    message: "In reply to themselves"
                  })
                ];
              }
          }
        }).call(this))))) : null, 彁("header", null, 彁(Shared.IDCard, {
          account: this.props.author
        }), 彁(ReactIntl.FormattedRelative, {
          value: Date.parse(this.props.datetime)
        }, (function(_this) {
          return function(formattedDate) {
            return 彁("time", {
              dateTime: _this.props.datetime,
              title: _this.props.datetime
            }, formattedDate);
          };
        })(this))), 彁("div", {
          className: "laboratory-statusContent",
          dangerouslySetInnerHTML: {
            __html: this.props.content
          }
        }), 彁("footer", null, 彁(Shared.Button, {
          className: "laboratory-button--minimal",
          containerClass: "laboratory-replybutton",
          icon: "reply",
          label: 彁(ReactIntl.FormattedMessage, {
            id: "status.reply",
            defaultMessage: "Reply"
          })
        }), this.props.isFavourited ? 彁(Shared.Button, {
          className: "laboratory-button--minimal",
          containerClass: "laboratory-unhighlightbutton",
          icon: "eraser",
          label: 彁(ReactIntl.FormattedMessage, {
            id: "status.unhighlight",
            defaultMessage: "Unhighlight"
          })
        }) : 彁(Shared.Button, {
          className: "laboratory-button--minimal",
          containerClass: "laboratory-highlightbutton",
          icon: "pencil",
          label: 彁(ReactIntl.FormattedMessage, {
            id: "status.highlight",
            defaultMessage: "Highlight"
          })
        }), this.props.isReblogged ? 彁(Shared.Button, {
          className: "laboratory-button--minimal",
          containerClass: "laboratory-unboostbutton",
          icon: "minus-square",
          label: 彁(ReactIntl.FormattedMessage, {
            id: "status.unboost",
            defaultMessage: "Unboost"
          })
        }) : this.props.visibility !== "private" ? 彁(Shared.Button, {
          className: "laboratory-button--minimal",
          containerClass: "laboratory-boostbutton",
          icon: "plus-square",
          label: 彁(ReactIntl.FormattedMessage, {
            id: "status.boost",
            defaultMessage: "Boost"
          })
        }) : 彁(Shared.Button, {
          className: "laboratory-button--minimal",
          containerClass: "laboratory-noboostbutton",
          icon: "square-o",
          disabled: true,
          label: 彁(ReactIntl.FormattedMessage, {
            id: "status.noboost",
            defaultMessage: "Private"
          })
        })));
      }
    }
  });

  Columns.Empty = function() {
    return 彁(Columns.Column, {
      id: "laboratory-empty"
    }, 彁(Columns.Heading));
  };

  Columns.Go = function(props) {
    var key, value;
    return 彁(Columns.Column, {
      id: "laboratory-go"
    }, 彁(Columns.Heading, {
      icon: "arrow-right"
    }, 彁(ReactIntl.FormattedMessage, {
      id: "go.heading",
      defaultMessage: "let's GO!"
    })), 彁("nav", {
      className: "laboratory-columnnav"
    }, 彁(Columns.GoLink, {
      to: "/user/" + props.myID,
      icon: "list-alt"
    }, 彁(ReactIntl.FormattedMessage, {
      id: 'go.profile',
      defaultMessage: "Profile"
    })), 彁(Columns.GoLink, {
      to: "/community",
      icon: "users"
    }, 彁(ReactIntl.FormattedMessage, {
      id: 'go.community',
      defaultMessage: "Community"
    })), 彁(Columns.GoLink, {
      to: "/global",
      icon: "link"
    }, 彁(ReactIntl.FormattedMessage, {
      id: 'go.global',
      defaultMessage: "Global"
    }))), 彁("footer", {
      className: "laboratory-columnfooter"
    }, 彁.apply(null, ["nav", null].concat(slice.call((function() {
      var ref1, results;
      ref1 = (props.footerLinks != null ? props.footerLinks : {});
      results = [];
      for (key in ref1) {
        value = ref1[key];
        results.push(彁("a", {
          href: value,
          target: "_self"
        }, key));
      }
      return results;
    })())))));
  };

  Columns.Go.propTypes = {
    footerLinks: React.PropTypes.object,
    myID: React.PropTypes.number.isRequired
  };

  Columns.NotFound = function() {
    return 彁(Columns.Column, {
      id: "laboratory-notfound"
    }, 彁(Columns.Heading, {
      icon: "exclamation-triangle"
    }, 彁(ReactIntl.FormattedMessage, {
      id: 'notfound.not_found',
      defaultMessage: "Not found"
    })), 彁(ReactIntl.FormattedMessage, {
      id: 'notfound.not_found',
      defaultMessage: "Not found"
    }));
  };

  Columns.Notifications = React.createClass({
    mixins: [ReactPureRenderMixin],
    getInitialState: function() {
      return {
        posts: {},
        postOrder: []
      };
    },
    handleResponse: function(timeline) {
      return this.setState(timeline);
    },
    componentWillMount: function() {
      return Laboratory.Timeline.Requested.dispatch({
        name: "notifications",
        callback: this.handleResponse
      });
    },
    componentWillUnmount: function() {
      return Laboratory.Timeline.Removed.dispatch({
        name: "notifications",
        callback: this.handleResponse
      });
    },
    render: function() {
      var id;
      return 彁(Columns.Column, {
        id: "laboratory-notifications"
      }, 彁(Columns.Heading, {
        icon: "star-half-o"
      }, 彁(ReactIntl.FormattedMessage, {
        id: "notifications.notifications",
        defaultMessage: "Notifications"
      })), 彁.apply(null, ["div", {
        className: "laboratory-posts"
      }].concat(slice.call((function() {
        var j, len, ref1, results;
        ref1 = this.state.postOrder;
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          id = ref1[j];
          results.push(彁(Columns.Status, this.state.posts[id]));
        }
        return results;
      }).call(this)))));
    }
  });

  Columns.Timeline = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      name: React.PropTypes.string.isRequired
    },
    getInitialState: function() {
      return {
        posts: {},
        postOrder: []
      };
    },
    handleResponse: function(timeline) {
      return this.setState(timeline);
    },
    getIcon: function() {
      switch (false) {
        case this.props.name !== "home":
          return "home";
        case this.props.name !== "community":
          return "users";
        case this.props.name !== "global":
          return "link";
        case this.props.name.substr(0, 8) !== "hashtag/":
          return "hashtag";
        case this.props.name.substr(0, 5) !== "user/":
          return "at";
        default:
          return "question-circle";
      }
    },
    componentWillReceiveProps: function(nextProps) {
      if (this.props.name === nextProps.name) {
        return;
      }
      Laboratory.Timeline.Removed.dispatch({
        name: this.props.name,
        callback: this.handleResponse
      });
      return Laboratory.Timeline.Requested.dispatch({
        name: nextProps.name,
        callback: this.handleResponse
      });
    },
    componentWillMount: function() {
      return Laboratory.Timeline.Requested.dispatch({
        name: this.props.name,
        callback: this.handleResponse
      });
    },
    componentWillUnmount: function() {
      return Laboratory.Timeline.Removed.dispatch({
        name: this.props.name,
        callback: this.handleResponse
      });
    },
    render: function() {
      var id;
      return 彁(Columns.Column, null, 彁(Columns.Heading, {
        icon: this.getIcon()
      }, 彁(ReactIntl.FormattedMessage, {
        id: "timeline." + this.props.name,
        defaultMessage: this.props.name.charAt(0).toLocaleUpperCase() + this.props.name.slice(1)
      })), 彁.apply(null, ["div", {
        className: "laboratory-posts"
      }].concat(slice.call((function() {
        var j, len, ref1, results;
        ref1 = this.state.postOrder;
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          id = ref1[j];
          results.push(彁(Columns.Status, this.state.posts[id]));
        }
        return results;
      }).call(this)))));
    }
  });

  Modules = {};

  Modules.Module = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      attributes: React.PropTypes.object,
      close: React.PropTypes.bool,
      closeTo: React.PropTypes.string
    },
    getInitialState: function() {
      return {
        shouldClose: this.props.close
      };
    },
    contextTypes: {
      router: React.PropTypes.object.isRequired
    },
    componentWillReceiveProps: function(nextProps) {
      if (!(nextProps.close && !this.state.shouldClose)) {
        return;
      }
      return this.close();
    },
    close: function() {
      this.setState({
        shouldClose: true
      });
      return window.setTimeout(((function(_this) {
        return function() {
          var ref1;
          if (_this.props.closeTo || ((ref1 = window.history) != null ? ref1.length : void 0) <= 1) {
            return _this.context.router.push(_this.props.closeTo || "/");
          } else {
            return _this.context.router.goBack();
          }
        };
      })(this)), 500);
    },
    render: function() {
      return 彁("div", (this.state.shouldClose ? {
        id: "laboratory-module",
        "data-laboratory-dismiss": ""
      } : {
        id: "laboratory-module"
      }), 彁("div", {
        id: "laboratory-curtain",
        onClick: this.close
      }), 彁("main", (this.props.attributes != null ? this.props.attributes : null), this.props.children));
    }
  });

  Modules.Account = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      id: React.PropTypes.number.isRequired,
      myID: React.PropTypes.number.isRequired
    },
    getInitialState: function() {
      return {
        account: null
      };
    },
    handleResponse: function(account) {
      return this.setState({
        account: account
      });
    },
    componentWillReceiveProps: function(nextProps) {
      if (this.props.id === nextProps.id) {
        return;
      }
      Laboratory.Account.Removed.dispatch({
        id: this.props.id,
        callback: this.handleResponse
      });
      return Laboratory.Account.Requested.dispatch({
        id: nextProps.id,
        callback: this.handleResponse
      });
    },
    componentWillMount: function() {
      return Laboratory.Account.Requested.dispatch({
        id: this.props.id,
        callback: this.handleResponse
      });
    },
    componentWillUnmount: function() {
      return Laboratory.Account.Removed.dispatch({
        id: this.props.id,
        callback: this.handleResponse
      });
    },
    render: function() {
      if (this.state.account == null) {
        return null;
      }
      return 彁(Modules.Module, {
        attributes: {
          id: "laboratory-account"
        }
      }, 彁("header", {
        style: {
          backgroundImage: "url(" + this.state.account.header + ")"
        }
      }, 彁("a", {
        src: this.state.account.header,
        target: "_blank"
      })), 彁(Shared.IDCard, {
        account: this.state.account,
        externalLinks: true
      }), (function() {
        switch (false) {
          case !(this.state.account.relationship & Laboratory.Relationship.SELF):
            return null;
          case !(this.state.account.relationship & Laboratory.Relationship.FOLLOWING):
            return 彁(Shared.Button, {
              label: 彁(ReactIntl.FormattedMessage, {
                id: "account.unfollow",
                defaultMessage: "Unfollow"
              }),
              icon: "user-times"
            });
          case !(this.state.account.relationship & Laboratory.Relationship.BLOCKING):
            return 彁(Shared.Button, {
              label: 彁(ReactIntl.FormattedMessage, {
                id: "account.blocked",
                defaultMessage: "Blocked"
              }),
              icon: "ban",
              disabled: true
            });
          case !(this.state.account.relationship & Laboratory.Relationship.REQUESTED):
            return 彁(Shared.Button, {
              label: 彁(ReactIntl.FormattedMessage, {
                id: "account.requestsent",
                defaultMessage: "Request Sent"
              }),
              icon: "share-square",
              disabled: true
            });
          default:
            if (this.state.account.locked) {
              return 彁(Shared.Button, {
                label: 彁(ReactIntl.FormattedMessage, {
                  id: "account.requestfollow",
                  defaultMessage: "Request Follow"
                }),
                icon: "user-secret"
              });
            } else {
              return 彁(Shared.Button, {
                label: 彁(ReactIntl.FormattedMessage, {
                  id: "account.follow",
                  defaultMessage: "Follow"
                }),
                icon: "user-plus"
              });
            }
        }
      }).call(this), 彁("p", {
        dangerouslySetInnerHTML: {
          __html: this.state.account.bio
        }
      }), 彁("footer", null, 彁("table", null, 彁("tbody", null, 彁("tr", null, 彁("td", null, 彁("b", null, this.state.account.statusCount), 彁(ReactIntl.FormattedMessage, {
        id: "account.statuses",
        defaultMessage: "Posts"
      })), 彁("td", null, 彁("b", null, this.state.account.followingCount), 彁(ReactIntl.FormattedMessage, {
        id: "account.following",
        defaultMessage: "Follows"
      })), 彁("td", null, 彁("b", null, this.state.account.followerCount), 彁(ReactIntl.FormattedMessage, {
        id: "account.followers",
        defaultMessage: "Followers"
      })))))));
    }
  });

  Modules.Composer = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      maxChars: React.PropTypes.number.isRequired,
      myID: React.PropTypes.number.isRequired,
      defaultPrivacy: React.PropTypes.string,
      visible: React.PropTypes.bool
    },
    getInitialState: function() {
      return {
        account: null,
        text: "\n",
        message: "",
        charsLeft: this.props.maxChars,
        makePublic: this.props.defaultPrivacy !== "private",
        makeListed: this.props.defaultPrivacy === "public",
        makeNSFW: false,
        forceNSFW: true,
        useMessage: false,
        shouldClose: false
      };
    },
    contextTypes: {
      intl: React.PropTypes.object.isRequired
    },
    handleResponse: function(account) {
      return this.setState({
        account: account
      });
    },
    componentWillMount: function() {
      return Laboratory.Account.Requested.dispatch({
        id: this.props.myID,
        callback: this.handleResponse
      });
    },
    componentWillUnmount: function() {
      return Laboratory.Account.Removed.dispatch({
        id: this.props.myID,
        callback: this.handleResponse
      });
    },
    input: {
      textbox: null,
      message: null,
      makePublic: null,
      makeListed: null,
      makeNSFW: null,
      useMessage: null,
      post: null
    },
    componentWillReceiveProps: function(nextProps) {
      if (!this.props.visible && nextProps.visible) {
        return this.setState({
          shouldClose: false
        });
      }
    },
    getCharsLeft: function() {
      return this.charsLeft = this.props.maxChars - (this.input.textbox.value + this.input.message.value).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length + 1;
    },
    format: function(text) {
      var i, j, lines, ref1, result;
      result = document.createElement("div");
      lines = text.split("\n");
      for (i = j = 0, ref1 = lines.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
        if (lines[i]) {
          result.appendChild(document.createTextNode(lines[i]));
        }
        if (i !== lines.length - 1 || lines[i]) {
          result.appendChild(document.createElement("br"));
        }
      }
      return result.innerHTML;
    },
    handleEvent: function(event) {
      switch (event.type) {
        case "change":
          switch (event.target) {
            case this.input.message:
              return this.setState({
                message: this.input.message.value,
                charsLeft: this.getCharsLeft()
              });
            case this.input.makePublic:
              return this.setState({
                makePublic: this.input.makePublic.checked,
                makeListed: this.input.makeListed.checked && this.input.makePublic.checked,
                forceListed: !this.input.makePublic.checked
              });
            case this.input.makeListed:
              return this.setState({
                makePublic: this.input.makePublic.checked || this.input.makeListed.checked,
                makeListed: this.input.makeListed.checked
              });
            case this.input.makeNSFW:
              return this.setState({
                makeNSFW: event.target.checked
              });
            case this.input.useMessage:
              return this.setState({
                useMessage: event.target.checked
              });
          }
          break;
        case "click":
          if (event.target === this.input.post && this.getCharsLeft() >= 0) {
            Laboratory.Composer.Post.dispatch({
              text: this.text,
              message: this.state.useMessage ? this.state.message : null,
              makePublic: this.state.makePublic,
              makeListed: this.state.makeListed,
              makeNSFW: this.state.makeNSFW
            });
            return this.setState({
              text: "",
              message: "",
              charsLeft: this.props.maxChars,
              useMessage: false,
              makeNSFW: false,
              forceNSFW: true,
              shouldClose: true
            });
          }
      }
    },
    render: function() {
      if (!this.props.visible) {
        return null;
      }
      return 彁(Modules.Module, {
        attributes: {
          id: "laboratory-composer"
        },
        close: this.state.shouldClose
      }, 彁("header", null, this.state.account ? 彁(Shared.IDCard, {
        account: this.state.account
      }) : null), 彁(Shared.Textbox, {
        id: "laboratory-composertextbox",
        "aria-label": this.context.intl.messages["composer.placeholder"],
        onChange: ((function(_this) {
          return function(text) {
            return _this.setState({
              text: text,
              charsLeft: _this.getCharsLeft()
            });
          };
        })(this)),
        value: this.format(this.state.text),
        ref: ((function(_this) {
          return function(ref) {
            return _this.input.textbox = ref;
          };
        })(this))
      }), 彁("footer", null, 彁("span", {
        id: "laboratory-count"
      }, isNaN(this.state.charsLeft) ? "" : this.state.charsLeft), 彁(Shared.Button, {
        onClick: this.handleEvent,
        getRef: ((function(_this) {
          return function(ref) {
            return _this.input.post = ref;
          };
        })(this)),
        disabled: this.state.charsLeft < 0,
        icon: "paper-plane-o",
        label: 彁(ReactIntl.FormattedMessage, {
          id: "composer.post",
          defaultMessage: "Post"
        })
      })), 彁("aside", {
        id: "laboratory-composeroptions"
      }, 彁("div", {
        id: "laboratory-postoptions"
      }, 彁(Shared.Toggle, {
        getRef: (function(_this) {
          return function(ref) {
            return _this.input.makePublic = ref;
          };
        })(this),
        checked: this.state.makePublic,
        onChange: this.handleEvent,
        inactiveText: 彁(ReactIntl.FormattedMessage, {
          id: "composer.private",
          defaultMessage: "Private"
        }),
        inactiveIcon: "microphone-slash",
        activeIcon: "rss",
        activeText: 彁(ReactIntl.FormattedMessage, {
          id: "composer.public",
          defaultMessage: "Public"
        })
      }), 彁(Shared.Toggle, {
        getRef: (function(_this) {
          return function(ref) {
            return _this.input.makeListed = ref;
          };
        })(this),
        checked: this.state.makeListed,
        onChange: this.handleEvent,
        inactiveText: 彁(ReactIntl.FormattedMessage, {
          id: "composer.unlisted",
          defaultMessage: "Unlisted"
        }),
        inactiveIcon: "envelope-o",
        activeIcon: "newspaper-o",
        activeText: 彁(ReactIntl.FormattedMessage, {
          id: "composer.listed",
          defaultMessage: "Listed"
        })
      }), 彁(Shared.Toggle, {
        getRef: (function(_this) {
          return function(ref) {
            return _this.input.makeNSFW = ref;
          };
        })(this),
        checked: this.state.makeNSFW,
        onChange: this.handleEvent,
        disabled: this.state.forceNSFW,
        inactiveText: 彁(ReactIntl.FormattedMessage, {
          id: "composer.safe",
          defaultMessage: "Safe"
        }),
        inactiveIcon: "picture-o",
        activeIcon: "exclamation",
        activeText: 彁(ReactIntl.FormattedMessage, {
          id: "composer.sensitive",
          defaultMessage: "Sensitive"
        })
      })), 彁("div", {
        id: "laboratory-hideoptions"
      }, 彁(Shared.Toggle, {
        getRef: (function(_this) {
          return function(ref) {
            return _this.input.useMessage = ref;
          };
        })(this),
        checked: this.state.useMessage,
        onChange: this.handleEvent,
        inactiveText: "",
        inactiveIcon: "ellipsis-h",
        activeIcon: "question-circle-o",
        activeText: 彁(ReactIntl.FormattedMessage, {
          id: "composer.hidewithmessage",
          defaultMessage: "Hide behind message"
        })
      }), 彁("input", {
        type: "text",
        placeholder: "…… ……",
        value: this.state.message,
        ref: (function(_this) {
          return function(ref) {
            return _this.input.message = ref;
          };
        })(this),
        onChange: this.handleEvent
      }))));
    }
  });

  Shared = {};

  Shared.Button = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      icon: React.PropTypes.string.isRequired,
      label: React.PropTypes.oneOfType([React.PropTypes.element, React.PropTypes.string]),
      getRef: React.PropTypes.func,
      containerClass: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        label: ""
      };
    },
    componentDidMount: function() {
      if (this.props.getRef) {
        return this.props.getRef(this.button);
      }
    },
    render: function() {
      var key, output_props, ref1, val;
      output_props = {
        className: "laboratory-button",
        ref: (function(_this) {
          return function(ref) {
            return _this.button = ref;
          };
        })(this)
      };
      ref1 = this.props;
      for (key in ref1) {
        if (!hasProp.call(ref1, key)) continue;
        val = ref1[key];
        if (key === "className") {
          output_props[key] += " " + val;
        } else if (["getRef", "ref", "label", "icon", "containerClass"].indexOf(key) === -1) {
          output_props[key] = val;
        }
      }
      return 彁("label", {
        className: "laboratory-buttoncontainer" + (this.props.containerClass ? " " + this.props.containerClass : "") + (this.props.disabled ? " laboratory-buttoncontainer--disabled" : "")
      }, this.props.label, 彁("button", output_props, 彁(Shared.Icon, {
        name: this.props.icon
      })));
    }
  });

  Shared.Icon = function(props) {
    return 彁('i', {
      className: "fa fa-fw fa-" + props.name,
      "aria-hidden": true
    });
  };

  Shared.Icon.propTypes = {
    name: React.PropTypes.string.isRequired
  };

  Shared.IDCard = function(props) {
    if (!(props.account instanceof Object)) {
      return null;
    }
    return 彁('div', {
      className: "laboratory-idcard"
    }, 彁('a', {
      href: props.account.avatar,
      target: "_blank"
    }, 彁('img', {
      className: "laboratory-avatar",
      src: props.account.avatar,
      alt: props.account.displayName
    })), 彁.apply(null, slice.call((props.externalLinks ? [
      "a", {
        href: props.account.href,
        title: props.account.displayName,
        target: "_blank"
      }
    ] : [
      ReactRouter.Link, {
        to: "user/" + props.account.id,
        title: props.account.displayName
      }
    ])).concat([彁('b', {
      className: "laboratory-displayname"
    }, props.account.displayName)], [彁('code', {
      className: "laboratory-username"
    }, props.account.localAccount)])));
  };

  Shared.IDCard.propTypes = {
    account: React.PropTypes.object.isRequired,
    externalLinks: React.PropTypes.bool
  };

  Shared.Textbox = React.createClass({
    propTypes: {
      getRef: React.PropTypes.func,
      onChange: React.PropTypes.func,
      className: React.PropTypes.string,
      id: React.PropTypes.string,
      'aria-label': React.PropTypes.string,
      value: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        value: "<br>"
      };
    },
    componentDidMount: function() {
      if (this.props.getRef != null) {
        this.props.getRef(this.input);
      }
      return this.value = this.getContents();
    },
    caret: 0,
    value: "\n",
    handleEvent: function(event) {
      var br, rng, sel;
      if (!((event.type === "input" || event.type === "blur" || event.type === "keypress") && event.target === this.input)) {
        return;
      }
      if (event.type === "keypress") {
        if (event.key === "Enter" || event.code === "Enter" || event.keyCode === 0x0D) {
          event.preventDefault();
          sel = window.getSelection();
          rng = sel.getRangeAt(0);
          rng.deleteContents();
          rng.insertNode(br = document.createElement("br"));
          rng.setEndAfter(br);
          rng.collapse(false);
          sel.removeAllRanges();
          sel.addRange(rng);
        } else {
          return;
        }
      }
      this.value = this.getContents();
      if (this.props.onChange) {
        return this.props.onChange(this.value);
      }
    },
    getContents: function() {
      var nde, out, wkr;
      wkr = document.createTreeWalker(this.input);
      nde = null;
      out = "";
      while (wkr.nextNode() != null) {
        nde = wkr.currentNode;
        if (nde.nodeType === Node.TEXT_NODE) {
          out += nde.textContent;
        } else if (nde.nodeType === Node.ELEMENT_NODE && nde.tagName.toUpperCase() === "BR") {
          out += "\n";
        }
      }
      if (out.length && out.slice(-1) !== "\n") {
        out += "\n";
      }
      return out;
    },
    shouldComponentUpdate: function(nextProps, nextState) {
      return this.props.value !== this.input.innerHTML;
    },
    updateCaretPos: function() {
      var brs, pre, rng, sel;
      this.caret = 0;
      sel = window.getSelection();
      rng = sel.getRangeAt(0);
      pre = rng.cloneRange();
      pre.selectNodeContents(this.input);
      pre.setEnd(rng.endContainer, rng.endOffset);
      brs = pre.cloneContents().querySelectorAll("br").length;
      this.caret = pre.toString().length + brs;
      pre.detach();
    },
    componentWillUpdate: function() {
      return this.updateCaretPos();
    },
    componentDidUpdate: function() {
      var idx, nde, ref1, ref2, rng, sel, success, wkr;
      sel = window.getSelection();
      rng = document.createRange();
      wkr = document.createTreeWalker(this.input);
      idx = 0;
      nde = null;
      success = false;
      if (this.caret >= this.value.length - 1) {
        success = true;
      }
      while (true) {
        if (wkr.nextNode() == null) {
          break;
        }
        nde = wkr.currentNode;
        if (nde.nodeType === Node.TEXT_NODE) {
          if ((idx <= (ref1 = this.caret) && ref1 <= idx + nde.textContent.length)) {
            success = true;
            break;
          } else {
            idx += nde.textContent.length;
          }
        } else if (nde.nodeType === Node.ELEMENT_NODE && nde.tagName.toUpperCase() === "BR") {
          if (idx++ === this.caret) {
            success = true;
            break;
          }
        } else {
          continue;
        }
      }
      if (success && nde) {
        if (nde.nodeType === Node.TEXT_NODE) {
          rng.setEnd(nde, this.caret - idx);
        } else {
          rng.selectNodeContents(nde);
        }
      } else if (((ref2 = this.input.lastChild) != null ? ref2.nodeName.toUpperCase : void 0) === "BR") {
        rng.setEnd(this.input, this.input.childNodes.length - 1);
      } else {
        rng.selectNodeContents(this.input);
      }
      rng.collapse(false);
      sel.removeAllRanges();
      return sel.addRange(rng);
    },
    render: function() {
      var key, output_props, ref1, value;
      output_props = {
        className: "laboratory-textbox" + (this.props.value.toLowerCase() === "<br>" || this.props.value === "\n" || this.props.value === "" ? " laboratory-textbox--empty" : "") + (this.props.className != null ? " " + this.props.className : ""),
        contentEditable: true,
        onKeyPress: this.handleEvent,
        onInput: this.handleEvent,
        onBlur: this.handleEvent,
        ref: (function(_this) {
          return function(ref) {
            return _this.input = ref;
          };
        })(this),
        dangerouslySetInnerHTML: {
          __html: this.props.value
        }
      };
      ref1 = this.props;
      for (key in ref1) {
        if (!hasProp.call(ref1, key)) continue;
        value = ref1[key];
        if (["className", "contentEditable", "value", "getRef", "onChange", "onInput", "onBlur", "dangerouslySetInnerHTML", "ref"].indexOf(key) === -1) {
          output_props[key] = value;
        }
      }
      return 彁("div", output_props);
    }
  });

  Shared.Toggle = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      checked: React.PropTypes.bool,
      disabled: React.PropTypes.bool,
      onChange: React.PropTypes.func,
      className: React.PropTypes.string,
      name: React.PropTypes.string,
      value: React.PropTypes.string,
      id: React.PropTypes.string,
      'aria-labelledby': React.PropTypes.string,
      'aria-label': React.PropTypes.string,
      getRef: React.PropTypes.func,
      activeText: React.PropTypes.oneOfType([React.PropTypes.element, React.PropTypes.string]),
      inactiveText: React.PropTypes.oneOfType([React.PropTypes.element, React.PropTypes.string]),
      activeicon: React.PropTypes.string,
      inactiveicon: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        activeText: 彁(ReactIntl.FormattedMessage, {
          id: "toggle.on",
          defaultMessage: "On"
        }),
        inactiveText: 彁(ReactIntl.FormattedMessage, {
          id: "toggle.off",
          defaultMessage: "Off"
        }),
        activeIcon: "check-circle-o",
        inactiveIcon: "times"
      };
    },
    getInitialState: function() {
      return {
        checked: !!this.props.checked,
        disabled: !!this.props.disabled,
        hasFocus: false
      };
    },
    componentWillReceiveProps: function(nextProps) {
      if (nextProps.checked != null) {
        this.setState({
          checked: !!nextProps.checked
        });
      }
      if (nextProps.disabled != null) {
        this.setState({
          disabled: !!nextProps.disabled
        });
      }
    },
    componentDidMount: function() {
      if (this.props.getRef != null) {
        return this.props.getRef(this.input);
      }
    },
    handleEvent: function(event) {
      switch (event.type) {
        case "click":
          if (event.target !== this.input) {
            event.preventDefault();
            this.input.focus();
            this.input.click();
          }
          return this.setState({
            checked: this.input.checked
          });
        case "onFocus":
          this.setState({
            hasFocus: true
          });
          if (this.props.onFocus) {
            return this.props.onFocus(event);
          }
          break;
        case "onBlur":
          this.setState({
            hasFocus: false
          });
          if (this.props.onBlur) {
            return this.props.onBlur(event);
          }
      }
    },
    render: function() {
      var key, output_props, ref1, value;
      output_props = {
        className: "laboratory-toggle-screenreader-only",
        type: "checkbox",
        onFocus: this.handleEvent,
        onBlur: this.handleEvent,
        ref: (function(_this) {
          return function(ref) {
            return _this.input = ref;
          };
        })(this)
      };
      ref1 = this.props;
      for (key in ref1) {
        if (!hasProp.call(ref1, key)) continue;
        value = ref1[key];
        if (["className", "activeText", "activeIcon", "inactiveText", "inactiveIcon", "getRef", "ref", "type", "onFocus", "onBlur"].indexOf(key) === -1) {
          output_props[key] = value;
        }
      }
      return 彁("label", {
        className: "laboratory-toggle" + (this.state.checked ? " laboratory-toggle--checked" : "") + (this.state.disabled ? " laboratory-toggle--disabled" : "") + (this.state.hasFocus ? " laboratory-toggle--focus" : "") + (this.props.className ? " " + this.props.className : ""),
        onClick: this.handleEvent
      }, 彁("span", {
        className: "laboratory-toggle-label laboratory-toggle-label-off"
      }, this.props.inactiveText), 彁("div", {
        className: "laboratory-toggle-track"
      }, 彁("div", {
        className: "laboratory-toggle-track-check"
      }, 彁(Shared.Icon, {
        name: this.props.activeIcon
      })), 彁("div", {
        className: "laboratory-toggle-track-x"
      }, 彁(Shared.Icon, {
        name: this.props.inactiveIcon
      })), 彁("div", {
        className: "laboratory-toggle-thumb"
      }), 彁("input", output_props)), 彁("span", {
        className: "laboratory-toggle-label laboratory-toggle-label-on"
      }, this.props.activeText));
    }
  });

  Shared.InstanceQuery = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      locale: React.PropTypes.string.isRequired,
      title: React.PropTypes.string,
      basename: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        title: "Labcoat",
        basename: "/web"
      };
    },
    getInitialState: function() {
      return {
        value: ""
      };
    },
    input: null,
    handleEvent: function(event) {
      if (event.type === "change" && event.target === this.input) {
        this.setState({
          value: this.input.value
        });
      } else if (event.type === "keypress" && event.target === this.input && (event.key === "Enter" || event.code === "Enter" || event.keyCode === 0x0D) && this.input.value.length && this.input.validity.valid) {
        window.open("about:blank", "LaboratoryOAuth");
        Laboratory.Authorization.Requested.dispatch({
          url: "https://" + this.input.value,
          redirect: this.props.basename,
          name: this.props.title
        });
        this.setState({
          value: ""
        });
      }
    },
    render: function() {
      return 彁(ReactIntl.IntlProvider, {
        locale: this.props.locale,
        messages: Locales[this.props.locale]
      }, 彁("div", {
        id: "laboratory-instancequery"
      }, 彁(ReactIntl.FormattedMessage, {
        id: "instancequery.queryinstance",
        defaultMessage: "What's your instance?"
      }), 彁("div", {
        id: "laboratory-instancequeryinput"
      }, 彁("code", {
        className: "laboratory-username"
      }, "username@"), 彁("input", {
        type: "text",
        pattern: "[0-9A-Za-z\-\.]+(\:[0-9]{1,4})?",
        placeholder: "example.com",
        value: this.state.value,
        ref: (function(_this) {
          return function(ref) {
            return _this.input = ref;
          };
        })(this),
        onChange: this.handleEvent,
        onKeyPress: this.handleEvent
      }))));
    }
  });

  Router = ReactRouter.Router, Route = ReactRouter.Route, IndexRoute = ReactRouter.IndexRoute;

  Shared.Frontend = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      locale: React.PropTypes.string.isRequired,
      myID: React.PropTypes.number.isRequired,
      title: React.PropTypes.string,
      links: React.PropTypes.object,
      basename: React.PropTypes.string,
      maxChars: React.PropTypes.number,
      useBrowserHistory: React.PropTypes.bool,
      defaultPrivacy: React.PropTypes.string
    },
    getDefaultProps: function() {
      return {
        title: "Labcoat",
        basename: "/web",
        maxChars: 500,
        defaultPrivacy: "unlisted",
        useBrowserHistory: true
      };
    },
    getInitialState: function() {
      return {
        thirdColumn: 彁(Columns.Empty),
        showComposer: false
      };
    },
    setThirdColumn: function(component, props) {
      return this.setState({
        thirdColumn: 彁(component, props)
      });
    },
    getThirdColumn: function() {
      return this.state.thirdColumn;
    },
    componentWillMount: function() {
      this.history = (this.props.useBrowserHistory ? ReactRouter.useRouterHistory(History.createHistory) : ReactRouter.useRouterHistory(History.createHashHistory))({
        basename: this.props.basename
      });
      this.routes = 彁(Route, {
        path: '/',
        component: (function(_this) {
          return function(props) {
            return 彁(UI.UI, {
              title: _this.props.title,
              maxChars: _this.props.maxChars,
              defaultPrivacy: _this.props.defaultPrivacy,
              thirdColumn: _this.getThirdColumn(),
              myID: _this.props.myID,
              showComposer: _this.state.showComposer
            }, props.children);
          };
        })(this)
      }, 彁(IndexRoute, {
        onEnter: (function(_this) {
          return function() {
            return _this.setThirdColumn(Columns.Go, {
              footerLinks: _this.props.links,
              myID: _this.props.myID
            });
          };
        })(this)
      }), 彁(Route, {
        path: 'start',
        onEnter: (function(_this) {
          return function() {
            return _this.setThirdColumn(Modules.Start);
          };
        })(this)
      }), 彁(Route, {
        path: 'global',
        onEnter: (function(_this) {
          return function() {
            return _this.setThirdColumn(Columns.Timeline, {
              name: 'global'
            });
          };
        })(this)
      }), 彁(Route, {
        path: 'community',
        onEnter: (function(_this) {
          return function() {
            return _this.setThirdColumn(Columns.Timeline, {
              name: 'community'
            });
          };
        })(this)
      }), 彁(Route, {
        path: 'hashtag/:id',
        onEnter: (function(_this) {
          return function(nextState) {
            return _this.setThirdColumn(Columns.Timeline, {
              name: 'hashtag/' + nextState.params.id
            });
          };
        })(this)
      }), 彁(Route, {
        path: 'compose',
        onEnter: ((function(_this) {
          return function() {
            return _this.setState({
              showComposer: true
            });
          };
        })(this)),
        onLeave: ((function(_this) {
          return function() {
            return _this.setState({
              showComposer: false
            });
          };
        })(this))
      }), 彁(Route, {
        path: 'post/:id',
        component: Modules.Post
      }), 彁(Route, {
        path: 'user/:id',
        component: (function(_this) {
          return function(props) {
            return 彁(Modules.Account, {
              id: Number(props.params.id),
              myID: _this.props.myID
            });
          };
        })(this)
      }), 彁(Route, {
        path: 'user/:id/posts',
        onEnter: (function(_this) {
          return function(nextState) {
            return _this.setThirdColumn(Columns.Timeline, {
              name: 'user/' + nextState.params.id
            });
          };
        })(this)
      }), 彁(Route, {
        path: '*',
        onEnter: (function(_this) {
          return function() {
            return _this.setThirdColumn(Columns.NotFound);
          };
        })(this)
      }));
    },
    componentWillUnmount: function() {
      if (this.subscription != null) {
        this.subscription.close();
        this.subscription = void 0;
      }
    },
    render: function() {
      return 彁(ReactIntl.IntlProvider, {
        locale: this.props.locale,
        messages: Locales[this.props.locale]
      }, 彁(Router, {
        history: this.history
      }, this.routes));
    }
  });

  UI = {};

  UI.Header = function(props) {
    return 彁('header', {
      id: "laboratory-header"
    }, 彁(UI.Title, null, props.title), 彁(ReactRouter.Link, {
      to: "/compose"
    }, 彁(Shared.Button, {
      icon: "pencil-square-o",
      label: 彁(ReactIntl.FormattedMessage, {
        id: "composer.compose",
        defaultMessage: "Compose"
      })
    })));
  };

  UI.Header.propTypes = {
    title: React.PropTypes.string
  };

  UI.Title = function(props) {
    return 彁('h1', null, 彁(ReactRouter.Link, {
      to: "/"
    }, props.children));
  };

  UI.UI = React.createClass({
    mixins: [ReactPureRenderMixin],
    propTypes: {
      title: React.PropTypes.string,
      maxChars: React.PropTypes.number.isRequired,
      myID: React.PropTypes.number.isRequired,
      thirdColumn: React.PropTypes.element.isRequired,
      showComposer: React.PropTypes.bool
    },
    handleEvent: function(e) {
      switch (e.type) {
        case "dragenter":
          return document.getElementById("laboratory-ui").setAttribute("data-laboratory-dragging", "");
        case "dragover":
          e.preventDefault();
          return e.dataTransfer.dropEffect = "copy";
        case "dragleave":
          if (e.relatedTarget == null) {
            return document.getElementById("laboratory-ui").removeAttribute("data-laboratory-dragging");
          }
          break;
        case "drop":
          e.preventDefault();
          return document.getElementById("laboratory-ui").removeAttribute("data-laboratory-dragging");
      }
    },
    componentWillMount: function() {
      document.addEventListener("dragenter", this);
      document.addEventListener("dragover", this);
      document.addEventListener("dragleave", this);
      return document.addEventListener("drop", this);
    },
    componentWillUnmount: function() {
      document.removeEventListener("dragenter", this);
      document.removeEventListener("dragover", this);
      document.removeEventListener("dragleave", this);
      return document.removeEventListener("drop", this);
    },
    render: function() {
      return 彁('div', {
        id: "laboratory-ui"
      }, 彁(UI.Header, {
        title: this.props.title
      }), 彁(Columns.Timeline, {
        name: "home"
      }), 彁(Columns.Notifications), this.props.thirdColumn, this.props.children, 彁(Modules.Composer, {
        defaultPrivacy: this.props.defaultPrivacy,
        myID: this.props.myID,
        maxChars: this.props.maxChars,
        visible: this.props.showComposer
      }));
    }
  });

  Locales = {};

  Locales.de = Object.freeze({
    "timeline.home": "Home",
    "notifications.notifications": "Mitteilungen",
    "composer.compose": "Schreiben",
    "notfound.not_found": "Nicht gefunden",
    "column_back_button.label": "Zurück",
    "lightbox.close": "Schließen",
    "loading_indicator.label": "Lade...",
    "status.mention": "Erwähnen",
    "status.delete": "Löschen",
    "status.reply": "Antworten",
    "status.reblog": "Teilen",
    "status.favourite": "Favorisieren",
    "status.reblogged_by": "{name} teilte",
    "status.sensitive_warning": "Sensible Inhalte",
    "status.sensitive_toggle": "Klicken um zu zeigen",
    "status.open": "Öffnen",
    "video_player.toggle_sound": "Ton umschalten",
    "account.mention": "Erwähnen",
    "account.edit_profile": "Profil bearbeiten",
    "account.unblock": "Entblocken",
    "account.unfollow": "Entfolgen",
    "account.block": "Blocken",
    "account.follow": "Folgen",
    "account.posts": "Beiträge",
    "account.follows": "Folgt",
    "account.followers": "Folger",
    "account.follows_you": "Folgt dir",
    "account.requested": "Warte auf Erlaubnis",
    "getting_started.heading": "Erste Schritte",
    "getting_started.about_addressing": "Du kannst Leuten folgen falls du ihren Nutzernamen und ihre Domain kennst in dem du eine e-mail-artige Addresse in das Suchfeld oben an der Seite eingibst.",
    "getting_started.about_shortcuts": "Falls der Zielnutzer an derselben Domain ist wie du funktioniert der Nutzername auch alleine. Das gilt auch für Erwähnungen in Beiträgen.",
    "getting_started.about_developer": "Der Entwickler des Projekts kann unter Gargron@mastodon.social gefunden werden",
    "getting_started.open_source_notice": "Mastodon ist quelloffene Software. Du kannst auf {github} dazu beitragen oder Probleme melden.",
    "column.home": "Home",
    "column.mentions": "Erwähnungen",
    "column.public": "Gesamtes Bekanntes Netz",
    "column.notifications": "Mitteilungen",
    "column.follow_requests": "Folgeanfragen",
    "tabs_bar.compose": "Schreiben",
    "tabs_bar.home": "Home",
    "tabs_bar.mentions": "Erwähnungen",
    "tabs_bar.public": "Gesamtes Netz",
    "tabs_bar.notifications": "Mitteilungen",
    "compose_form.placeholder": "Worüber möchstest du schreiben?",
    "compose_form.publish": "Veröffentlichen",
    "compose_form.sensitive": "Medien als sensitiv markieren",
    "compose_form.unlisted": "Öffentlich nicht auflisten",
    "compose_form.private": "Als privat markieren",
    "navigation_bar.edit_profile": "Profil bearbeiten",
    "navigation_bar.preferences": "Einstellungen",
    "navigation_bar.public_timeline": "Öffentlich",
    "navigation_bar.logout": "Abmelden",
    "navigation_bar.follow_requests": "Folgeanfragen",
    "reply_indicator.cancel": "Abbrechen",
    "search.placeholder": "Suche",
    "search.account": "Konto",
    "search.hashtag": "Hashtag",
    "upload_button.label": "Media-Datei anfügen",
    "upload_form.undo": "Entfernen",
    "notification.follow": "{name} folgt dir",
    "notification.favourite": "{name} favorisierte deinen Status",
    "notification.reblog": "{name} teilte deinen Status",
    "notification.mention": "{name} erwähnte dich",
    "notifications.column_settings.alert": "Desktop-Benachrichtigunen",
    "notifications.column_settings.show": "In der Spalte anzeigen",
    "notifications.column_settings.follow": "Neue Folger:",
    "notifications.column_settings.favourite": "Favorisierungen:",
    "notifications.column_settings.mention": "Erwähnungen:",
    "notifications.column_settings.reblog": "Geteilte Beiträge:",
    "follow_request.authorize": "Erlauben",
    "follow_request.reject": "Ablehnen",
    "home.column_settings.basic": "Einfach",
    "home.column_settings.advanced": "Fortgeschritten",
    "home.column_settings.show_reblogs": "Geteilte Beiträge anzeigen",
    "home.column_settings.show_replies": "Antworten anzeigen",
    "home.column_settings.filter_regex": "Filter durch reguläre Ausdrücke",
    "missing_indicator.label": "Nicht gefunden"
  });

  Locales.en = Object.freeze({
    "timeline.home": "Home",
    "notifications.notifications": "Notifications",
    "composer.compose": "Compose",
    "composer.post": "Post",
    "composer.private": "Private",
    "composer.public": "Public",
    "composer.unlisted": "Unlisted",
    "composer.listed": "Listed",
    "composer.safe": "Safe",
    "composer.sensitive": "Sensitive",
    "composer.hidewithmessage": "Hide behind message",
    "composer.placeholder": "What's going on?",
    "account.follow": "Follow",
    "account.unfollow": "Unfollow",
    "account.blocking": "Blocking",
    "account.requestfollow": "Request Follow",
    "account.requestsent": "Request Sent",
    "account.statuses": "Posts",
    "account.following": "Follows",
    "account.followers": "Followers",
    "status.and": " and ",
    "status.etal": " et al.",
    "status.followedyou": " followed you!",
    "status.boostedthisreplyto": " boosted this reply to ",
    "status.boostedthisreply": " boosted this reply",
    "status.boostedthispost": " boosted this post",
    "status.highlightedthisreplyto": " highlighted this reply to ",
    "status.highlightedthisreply": " highlighted this reply",
    "status.highlightedthispost": " highlighted this post",
    "status.inreplyto": "In reply to ",
    "status.inreplytoself": "In reply to themselves",
    "go.heading": "let's GO!",
    "go.community": "Community",
    "go.global": "Global",
    "toggle.off": "Off",
    "toggle.on": "On",
    "notfound.not_found": "Not found",
    "column_back_button.label": "Back",
    "lightbox.close": "Close",
    "loading_indicator.label": "Loading...",
    "status.mention": "Mention",
    "status.delete": "Delete",
    "status.reply": "Reply",
    "status.reblog": "Boost",
    "status.favourite": "Favourite",
    "status.reblogged_by": "{name} boosted",
    "status.sensitive_warning": "Sensitive content",
    "status.sensitive_toggle": "Click to view",
    "video_player.toggle_sound": "Toggle sound",
    "account.mention": "Mention",
    "account.edit_profile": "Edit profile",
    "account.unblock": "Unblock",
    "account.unfollow": "Unfollow",
    "account.block": "Block",
    "account.follow": "Follow",
    "account.posts": "Posts",
    "account.follows": "Follows",
    "account.followers": "Followers",
    "account.follows_you": "Follows you",
    "account.requested": "Awaiting approval",
    "getting_started.heading": "Getting started",
    "getting_started.about_addressing": "You can follow people if you know their username and the domain they are on by entering an e-mail-esque address into the search form.",
    "getting_started.about_shortcuts": "If the target user is on the same domain as you just the username will work. The same rule applies to mentioning people in statuses.",
    "getting_started.about_developer": "The developer of this project can be followed as Gargron@mastodon.social",
    "getting_started.open_source_notice": "Mastodon is open source software. You can contribute or report issues on github at {github}.",
    "column.home": "Home",
    "column.mentions": "Mentions",
    "column.public": "Public",
    "column.notifications": "Notifications",
    "tabs_bar.compose": "Compose",
    "tabs_bar.home": "Home",
    "tabs_bar.mentions": "Mentions",
    "tabs_bar.public": "Public",
    "tabs_bar.notifications": "Notifications",
    "compose_form.placeholder": "What is on your mind?",
    "compose_form.publish": "Toot",
    "compose_form.sensitive": "Mark media as sensitive",
    "compose_form.spoiler": "Hide text behind warning",
    "compose_form.private": "Mark as private",
    "compose_form.privacy_disclaimer": "Your private status will be delivered to mentioned users on {domains}. Do you trust {domainsCount plural one {that server} other {those servers}} to not leak your status?",
    "compose_form.unlisted": "Do not display in public timeline",
    "navigation_bar.edit_profile": "Edit profile",
    "navigation_bar.preferences": "Preferences",
    "navigation_bar.public_timeline": "Public timeline",
    "navigation_bar.logout": "Logout",
    "reply_indicator.cancel": "Cancel",
    "search.placeholder": "Search",
    "search.account": "Account",
    "search.hashtag": "Hashtag",
    "upload_button.label": "Add media",
    "upload_form.undo": "Undo",
    "notification.follow": "{name} followed you",
    "notification.favourite": "{name} favourited your status",
    "notification.reblog": "{name} boosted your status",
    "notification.mention": "{name} mentioned you",
    "notifications.column_settings.alert": "Desktop notifications",
    "notifications.column_settings.show": "Show in column",
    "notifications.column_settings.follow": "New followers:",
    "notifications.column_settings.favourite": "Favourites:",
    "notifications.column_settings.mention": "Mentions:",
    "notifications.column_settings.reblog": "Boosts:",
    "missing_indicator.label": "Not found"
  });

  Locales.es = Object.freeze({
    "timeline.home": "Inicio",
    "notifications.notifications": "Notificaciones",
    "composer.compose": "Redactar",
    "notfound.not_found": "No encontrada",
    "column_back_button.label": "Atrás",
    "lightbox.close": "Cerrar",
    "loading_indicator.label": "Cargando...",
    "status.mention": "Mencionar",
    "status.delete": "Borrar",
    "status.reply": "Responder",
    "status.reblog": "Republicar",
    "status.favourite": "Favorito",
    "status.reblogged_by": "{name} republicado",
    "video_player.toggle_sound": "Act/Desac. sonido",
    "account.mention": "Mención",
    "account.edit_profile": "Editar perfil",
    "account.unblock": "Desbloquear",
    "account.unfollow": "Dejar de seguir",
    "account.block": "Bloquear",
    "account.follow": "Seguir",
    "account.block": "Bloquear",
    "account.posts": "Publicaciones",
    "account.follows": "Seguir",
    "account.followers": "Seguidores",
    "account.follows_you": "Te sigue",
    "getting_started.heading": "Primeros pasos",
    "getting_started.about_addressing": "Puedes seguir a gente si conoces su nombre de usuario y el dominio en el que están registrados introduciendo algo similar a una dirección de correo electrónico en el formulario en la parte superior de la barra lateral.",
    "getting_started.about_shortcuts": "Si el usuario que buscas está en el mismo dominio que tú simplemente funcionará introduciendo el nombre de usuario. La misma regla se aplica para mencionar a usuarios.",
    "getting_started.about_developer": "Puedes seguir al desarrollador de este proyecto en Gargron@mastodon.social",
    "column.home": "Inicio",
    "column.mentions": "Menciones",
    "column.public": "Historia pública",
    "column.notifications": "Notificaciones",
    "tabs_bar.compose": "Redactar",
    "tabs_bar.home": "Inicio",
    "tabs_bar.mentions": "Menciones",
    "tabs_bar.public": "Público",
    "tabs_bar.notifications": "Notificaciones",
    "compose_form.placeholder": "¿En qué estás pensando?",
    "compose_form.publish": "Publicar",
    "compose_form.sensitive": "Marcar el contenido como sensible",
    "compose_form.unlisted": "Privado",
    "navigation_bar.edit_profile": "Editar perfil",
    "navigation_bar.preferences": "Preferencias",
    "navigation_bar.public_timeline": "Público",
    "navigation_bar.logout": "Cerrar sesión",
    "reply_indicator.cancel": "Cancelar",
    "search.placeholder": "Buscar",
    "search.account": "Cuenta",
    "search.hashtag": "Etiqueta",
    "upload_button.label": "Añadir medio",
    "upload_form.undo": "Deshacer",
    "notification.follow": "{name} le esta ahora siguiendo",
    "notification.favourite": "{name} marcó como favorito su estado",
    "notification.reblog": "{name} volvió a publicar su estado",
    "notification.mention": "Fue mencionado por {name}"
  });

  Locales.fr = Object.freeze({
    "timeline.home": "Accueil",
    "notifications.notifications": "Notifications",
    "composer.compose": "Composer",
    "notfound.not_found": "Pas trouvé",
    "column_back_button.label": "Retour",
    "lightbox.close": "Fermer",
    "loading_indicator.label": "Chargement…",
    "status.mention": "Mentionner",
    "status.delete": "Effacer",
    "status.reply": "Répondre",
    "status.reblog": "Partager",
    "status.favourite": "Ajouter aux favoris",
    "status.reblogged_by": "{name} a partagé :",
    "status.sensitive_warning": "Contenu délicat",
    "status.sensitive_toggle": "Cliquer pour dévoiler",
    "video_player.toggle_sound": "Mettre/Couper le son",
    "account.mention": "Mentionner",
    "account.edit_profile": "Modifier le profil",
    "account.unblock": "Débloquer",
    "account.unfollow": "Ne plus suivre",
    "account.block": "Bloquer",
    "account.follow": "Suivre",
    "account.posts": "Statuts",
    "account.follows": "Abonnements",
    "account.followers": "Abonnés",
    "account.follows_you": "Vous suit",
    "getting_started.heading": "Pour commencer",
    "getting_started.about_addressing": "Vous pouvez vous suivre les statuts de quelqu’un en entrant dans le champs de recherche leur identifiant et le domaine de leur instance séparés par un @ à la manière d’une adresse courriel.",
    "getting_started.about_shortcuts": "Si cette personne utilise la même instance que vous l’identifiant suffit. C’est le même principe pour mentionner quelqu’un dans vos statuts.",
    "getting_started.about_developer": "Pour suivre le développeur de ce projet c’est Gargron@mastodon.social",
    "column.home": "Accueil",
    "column.mentions": "Mentions",
    "column.public": "Fil public",
    "column.notifications": "Notifications",
    "tabs_bar.compose": "Composer",
    "tabs_bar.home": "Accueil",
    "tabs_bar.mentions": "Mentions",
    "tabs_bar.public": "Public",
    "tabs_bar.notifications": "Notifications",
    "compose_form.placeholder": "Qu’avez-vous en tête ?",
    "compose_form.publish": "Pouet",
    "compose_form.sensitive": "Marquer le contenu comme délicat",
    "compose_form.unlisted": "Ne pas apparaître dans le fil public",
    "navigation_bar.edit_profile": "Modifier le profil",
    "navigation_bar.preferences": "Préférences",
    "navigation_bar.public_timeline": "Public",
    "navigation_bar.logout": "Déconnexion",
    "reply_indicator.cancel": "Annuler",
    "search.placeholder": "Chercher",
    "search.account": "Compte",
    "search.hashtag": "Mot-clé",
    "upload_button.label": "Joindre un média",
    "upload_form.undo": "Annuler",
    "notification.follow": "{name} vous suit.",
    "notification.favourite": "{name} a ajouté à ses favoris :",
    "notification.reblog": "{name} a partagé votre statut :",
    "notification.mention": "{name} vous a mentionné⋅e :"
  });

  Locales.hu = Object.freeze({
    "timeline.home": "Kezdőlap",
    "notifications.notifications": "Értesítések",
    "composer.compose": "Összeállítás",
    "notfound.not_found": "Nem található",
    "column_back_button.label": "Vissza",
    "lightbox.close": "Bezárás",
    "loading_indicator.label": "Betöltés...",
    "status.mention": "Említés",
    "status.delete": "Törlés",
    "status.reply": "Válasz",
    "status.reblog": "Reblog",
    "status.favourite": "Kedvenc",
    "status.reblogged_by": "{name} reblogolta",
    "status.sensitive_warning": "Érzékeny tartalom",
    "status.sensitive_toggle": "Katt a megtekintéshez",
    "video_player.toggle_sound": "Hang kapcsolása",
    "account.mention": "Említés",
    "account.edit_profile": "Profil szerkesztése",
    "account.unblock": "Blokkolás levétele",
    "account.unfollow": "Követés abbahagyása",
    "account.block": "Blokkolás",
    "account.follow": "Követés",
    "account.posts": "Posts",
    "account.follows": "Követők",
    "account.followers": "Követők",
    "account.follows_you": "Követnek téged",
    "getting_started.heading": "Első lépések",
    "getting_started.about_addressing": "Követhetsz embereket felhasználónevük és a doménjük ismeretében amennyiben megadod ezt az e-mail-szerű címet az oldalsáv tetején lévő rubrikában.",
    "getting_started.about_shortcuts": "Ha a célzott személy azonos doménen tartózkodik a felhasználónév elegendő. Ugyanez érvényes mikor személyeket említesz az állapotokban.",
    "getting_started.about_developer": "A projekt fejlesztője követhető mint Gargron@mastodon.social",
    "column.home": "Kezdőlap",
    "column.mentions": "Említések",
    "column.public": "Nyilvános",
    "column.notifications": "Értesítések",
    "tabs_bar.compose": "Összeállítás",
    "tabs_bar.home": "Kezdőlap",
    "tabs_bar.mentions": "Említések",
    "tabs_bar.public": "Nyilvános",
    "tabs_bar.notifications": "Notifications",
    "compose_form.placeholder": "Mire gondolsz?",
    "compose_form.publish": "Tülk!",
    "compose_form.sensitive": "Tartalom érzékenynek jelölése",
    "compose_form.unlisted": "Listázatlan mód",
    "navigation_bar.edit_profile": "Profil szerkesztése",
    "navigation_bar.preferences": "Beállítások",
    "navigation_bar.public_timeline": "Nyilvános időfolyam",
    "navigation_bar.logout": "Kijelentkezés",
    "reply_indicator.cancel": "Mégsem",
    "search.placeholder": "Keresés",
    "search.account": "Fiók",
    "search.hashtag": "Hashtag",
    "upload_button.label": "Média hozzáadása",
    "upload_form.undo": "Mégsem",
    "notification.follow": "{name} követ téged",
    "notification.favourite": "{name} kedvencnek jelölte az állapotod",
    "notification.reblog": "{name} reblogolta az állapotod",
    "notification.mention": "{name} megemlített"
  });

  Locales.pt = Object.freeze({
    "timeline.home": "Home",
    "notifications.notifications": "Notificações",
    "composer.compose": "Compôr",
    "notfound.not_found": "Não encontrada",
    "column_back_button.label": "Voltar",
    "lightbox.close": "Fechar",
    "loading_indicator.label": "Carregando...",
    "status.mention": "Menção",
    "status.delete": "Deletar",
    "status.reply": "Responder",
    "status.reblog": "Reblogar",
    "status.favourite": "Favoritar",
    "status.reblogged_by": "{name} reblogou",
    "video_player.toggle_sound": "Alterar som",
    "account.mention": "Menção",
    "account.edit_profile": "Editar perfil",
    "account.unblock": "Desbloquear",
    "account.unfollow": "Unfollow",
    "account.block": "Bloquear",
    "account.follow": "Seguir",
    "account.block": "Bloquear",
    "account.posts": "Posts",
    "account.follows": "Segue",
    "account.followers": "Seguidores",
    "account.follows_you": "Segue você",
    "getting_started.heading": "Primeiros passos",
    "getting_started.about_addressing": "Podes seguir pessoas se sabes o nome de usuário deles e o domínio em que estão entrando um endereço similar a e-mail no campo no topo da barra lateral.",
    "getting_started.about_shortcuts": "Se o usuário alvo está no mesmo domínio só o nome funcionará. A mesma regra se aplica a mencionar pessoas nas postagens.",
    "getting_started.about_developer": "O desenvolvedor desse projeto pode ser seguido em Gargron@mastodon.social",
    "column.home": "Home",
    "column.mentions": "Menções",
    "column.public": "Público",
    "tabs_bar.compose": "Compôr",
    "tabs_bar.home": "Home",
    "tabs_bar.mentions": "Menções",
    "tabs_bar.public": "Público",
    "tabs_bar.notifications": "Notificações",
    "compose_form.placeholder": "Que estás pensando?",
    "compose_form.publish": "Publicar",
    "compose_form.sensitive": "Marcar conteúdo como sensível",
    "compose_form.unlisted": "Modo não-listado",
    "navigation_bar.edit_profile": "Editar perfil",
    "navigation_bar.preferences": "Preferências",
    "navigation_bar.public_timeline": "Timeline Pública",
    "navigation_bar.logout": "Logout",
    "reply_indicator.cancel": "Cancelar",
    "search.placeholder": "Busca",
    "search.account": "Conta",
    "search.hashtag": "Hashtag",
    "upload_button.label": "Adicionar media",
    "upload_form.undo": "Desfazer",
    "notification.follow": "{name} seguiu você",
    "notification.favourite": "{name} favoritou  seu post",
    "notification.reblog": "{name} reblogou o seu post",
    "notification.mention": "{name} mecionou você"
  });

  Locales.uk = Object.freeze({
    "timeline.home": "Головна",
    "notifications.notifications": "Сповіщення",
    "composer.compose": "Написати",
    "notfound.not_found": "Не знайдено",
    "column_back_button.label": "Назад",
    "lightbox.close": "Закрити",
    "loading_indicator.label": "Завантаження...",
    "status.mention": "Згадати",
    "status.delete": "Видалити",
    "status.reply": "Відповісти",
    "status.reblog": "Передмухнути",
    "status.favourite": "Подобається",
    "status.reblogged_by": "{name} передмухнув(-ла)",
    "status.sensitive_warning": "Непристойний зміст",
    "status.sensitive_toggle": "Натисніть щоб подивитися",
    "video_player.toggle_sound": "Увімкнути/вимкнути звук",
    "account.mention": "Згадати",
    "account.edit_profile": "Налаштування профілю",
    "account.unblock": "Розблокувати",
    "account.unfollow": "Відписатися",
    "account.block": "Заблокувати",
    "account.follow": "Підписатися",
    "account.posts": "Пости",
    "account.follows": "Підписки",
    "account.followers": "Підписники",
    "account.follows_you": "Підписаний",
    "getting_started.heading": "Ласкаво просимо",
    "getting_started.about_addressing": "Ви можете підписуватись на людей якщо ви знаєте їх ім'я користувача чи домен шляхом введення email-подібної адреси у верхньому рядку бокової панелі.",
    "getting_started.about_shortcuts": "Якщо користувач якого ви шукаєте знаходиться на тому ж домені що й ви можна просто ввести ім'я користувача. Це правило стосується й згадування людей у статусах.",
    "getting_started.about_developer": "Розробник проекту знаходиться за адресою Gargron@mastodon.social",
    "column.home": "Головна",
    "column.mentions": "Згадування",
    "column.public": "Стіна",
    "column.notifications": "Сповіщення",
    "tabs_bar.compose": "Написати",
    "tabs_bar.home": "Головна",
    "tabs_bar.mentions": "Згадування",
    "tabs_bar.public": "Стіна",
    "tabs_bar.notifications": "Сповіщення",
    "compose_form.placeholder": "Що у Вас на думці?",
    "compose_form.publish": "Дмухнути",
    "compose_form.sensitive": "Непристойний зміст",
    "compose_form.unlisted": "Таємний режим",
    "navigation_bar.edit_profile": "Редагувати профіль",
    "navigation_bar.preferences": "Налаштування",
    "navigation_bar.public_timeline": "Публічна стіна",
    "navigation_bar.logout": "Вийти",
    "reply_indicator.cancel": "Відмінити",
    "search.placeholder": "Пошук",
    "search.account": "Аккаунт",
    "search.hashtag": "Хештеґ",
    "upload_button.label": "Додати медіа",
    "upload_form.undo": "Відмінити",
    "notification.follow": "{name} підписався(-лась) на Вас",
    "notification.favourite": "{name} сподобався ваш допис",
    "notification.reblog": "{name} передмухнув(-ла) Ваш статус",
    "notification.mention": "{name} згадав(-ла) Вас"
  });

  Object.defineProperty(window, "Labcoat", {
    value: Object.freeze({
      ℹ: "\n............... LABCOAT ................\n\n A client-side frontend for Mastodon, a\nfree & open-source social network server\n           - - by Kibigo! - -\n\n    Licensed under the MIT License.\n       Source code available at:\n  https://github.com/marrus-sh/labcoat\n\n            Version 0.1.0\n",
      Nº: 1.0
    }),
    enumerable: true
  });

  ReactIntl.addLocaleData(slice.call(ReactIntlLocaleData.en).concat(slice.call(ReactIntlLocaleData.de), slice.call(ReactIntlLocaleData.es), slice.call(ReactIntlLocaleData.fr), slice.call(ReactIntlLocaleData.pt), slice.call(ReactIntlLocaleData.hu), slice.call(ReactIntlLocaleData.uk)));

  config = document.documentElement.hasAttribute("data-labcoat-config") ? JSON.parse(document.documentElement.getAttribute("data-labcoat-config")) : {};

  if ((typeof INITIAL_STATE !== "undefined" && INITIAL_STATE !== null ? INITIAL_STATE.meta : void 0) == null) {
    INITIAL_STATE = {
      meta: {}
    };
  }

  ref1 = ["title", "basename", "useBrowserHistory", "locale", "root", "defaultPrivacy", "accessToken", "origin"];
  for (j = 0, len = ref1.length; j < len; j++) {
    prop = ref1[j];
    if (config[prop] == null) {
      config[prop] = {
        title: INITIAL_STATE.meta.title || "Labcoat",
        basename: INITIAL_STATE.meta.router_basename != null ? INITIAL_STATE.meta.router_basename : "/web",
        useBrowserHistory: INITIAL_STATE.meta.use_history || (INITIAL_STATE.meta.use_history == null),
        locale: INITIAL_STATE.meta.locale,
        root: INITIAL_STATE.meta.react_root,
        defaultPrivacy: ((ref2 = INITIAL_STATE.composer) != null ? ref2.default_privacy : void 0) || "unlisted",
        accessToken: INITIAL_STATE.meta.accessToken,
        origin: INITIAL_STATE.meta.origin || "/"
      }[prop];
    }
  }

  if (config.display != null) {
    if (indexOf.call(config.display, "simple") >= 0) {
      document.documentElement.setAttribute("data-labcoat-simple");
    } else {
      document.documentElement.removeAttribute("data-labcoat-simple");
    }
    if (indexOf.call(config.display, "no-transparency") >= 0) {
      document.documentElement.setAttribute("data-labcoat-no-transparency");
    } else {
      document.documentElement.removeAttribute("data-labcoat-no-transparency");
    }
    if (indexOf.call(config.display, "reduce-motion") >= 0) {
      document.documentElement.setAttribute("data-labcoat-reduce-motion");
    } else {
      document.documentElement.removeAttribute("data-labcoat-reduce-motion");
    }
  }

  run = function() {
    var callback, elt;
    document.title = config.title;
    config.root = (function() {
      switch (false) {
        case !(config.root && (elt = document.getElementById(String(config.root)))):
          return elt;
        case !(elt = document.getElementById("frontend")):
          return elt;
        case !(elt = document.getElementsByClassName("app-body").item(0)):
          return elt;
        default:
          return document.body;
      }
    })();
    if (config.accessToken) {
      Laboratory.Initialization.Received.dispatch({
        data: {
          access_token: config.accessToken
        }
      });
    } else {
      ReactDOM.render(彁(Shared.InstanceQuery, {
        title: config.title,
        locale: config.locale,
        basename: config.basename
      }), config.root);
    }
    callback = function() {
      ReactDOM.unmountComponentAtNode(config.root);
      ReactDOM.render(彁(Shared.Frontend, {
        title: config.title,
        locale: config.locale,
        myID: Laboratory.user,
        useBrowserHistory: config.useBrowserHistory,
        basename: config.basename,
        defaultPrivacy: config.defaultPrivacy
      }), config.root);
      return document.removeEventListener("LaboratoryAccountReceived", callback);
    };
    return document.addEventListener("LaboratoryAccountReceived", callback);
  };

  if (typeof Laboratory !== "undefined" && Laboratory !== null ? Laboratory.ready : void 0) {
    run();
  } else {
    document.addEventListener("LaboratoryInitializationReady", run);
  }

}).call(this);
